diff --git a/index.html b/index.html
index 572acc45559ccc550731630e3e7d27dcd4902120..8c8fa41c4f928c3e9c2e988fa02ad84118dac436 100644
--- a/index.html
+++ b/index.html
@@ -1,129 +1,132 @@
 <!DOCTYPE html>
 <html lang="en">
 <head>
     <meta charset="UTF-8">
     <meta name="viewport" content="width=device-width, initial-scale=1.0">
     <title>ACC Livery Viewer</title>
-	<script type="importmap"> { 
-        "imports": { 
-            "three": "https://cdn.jsdelivr.net/npm/three@0.169.0/build/three.module.js", 
+        <script type="importmap"> {
+        "imports": {
+            "three": "https://cdn.jsdelivr.net/npm/three@0.169.0/build/three.module.js",
             "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.169.0/examples/jsm/"
-            } 
+            }
         } </script>
     <link href="https://cdn.jsdelivr.net/npm/bootstrap@5/dist/css/bootstrap.min.css" rel="stylesheet">
     <script src="https://cdn.jsdelivr.net/npm/bootstrap@5/dist/js/bootstrap.min.js"></script>
     <link rel="stylesheet" href="style.css">
     <script src="data.js"></script>
     <script src="util.js"></script>
     <script type="module" src="colour-picker.js"></script>
     <script type="module" src="main.js" defer></script>
 </head>
 <body class="bg-light">
 
     <input type="file" id="fileInput" style="display: none;" multiple>
 
-    <div class="container-fluid mt-2">
-      <div id="settingsLayer" class="row">
+    <div class="app-shell">
+      <button id="editorPanelToggle" class="editor-panel-toggle btn btn-primary" aria-expanded="false" aria-controls="editorPanel">Editor Tools</button>
+      <div class="app-main">
+        <div class="container-fluid mt-2">
+          <div id="settingsLayer" class="row">
             <div class="col-md-3">
             <div class="card">
               <div class="card-header p-2">Render Settings</div>
               <div class="card-body p-2">
                 <div class="form-check">
                   <input class="form-check-input" type="checkbox" id="skybox-toggle">
                   <label class="form-check-label" for="skybox-toggle">Enable Skybox</label>
                 </div>
 
                 <div class="form-check">
                   <input class="form-check-input" type="checkbox" id="post-processing-toggle" checked>
                   <label class="form-check-label" for="post-processing-toggle">Enable Post-processing</label>
                 </div>
 
                 <div class="mb-2">
                   <label for="cubemapSelector" class="form-label form-label-sm">Cubemap:</label>
                   <select class="form-select form-select-sm" id="cubemapSelector"></select>
                 </div>
               </div>
             </div>
           </div>
-          
+
           <div class="col-md-3">
             <div class="card">
               <div class="card-header p-2">Car Settings</div>
               <div class="card-body p-2">
                 <div class="row">
                   <div class="col-6">
                     <label for="modelSelector" class="form-label form-label-sm">Car:</label>
                     <select class="form-select form-select-sm" id="modelSelector"></select>
                   </div>
                   <div class="col-6">
                     <label for="liverySelector" class="form-label form-label-sm">Skin:</label>
                     <select class="form-select form-select-sm" id="liverySelector"></select>
                   </div>
                 </div>
                 <div class="mb-2">
                   <label for="lodSelector" class="form-label form-label-sm">Level of Detail:</label>
                   <select class="form-select form-select-sm" id="lodSelector">
                       <option value="1">1</option>
                       <option value="2">2</option>
                       <option value="3" selected="selected">3</option>
                       <option value="4">4</option>
                   </select>
                 </div>
               </div>
             </div>
           </div>
-          
+
           <div class="col-md-3">
             <div class="card">
               <div class="card-header p-2">Livery Settings</div>
               <div class="card-body p-2">
                 <div class="mb-2">
                   <label for="multiFileUpload" class="form-label form-label-sm">Upload Livery Files:</label>
                   <input type="file" class="form-control form-control-sm" id="multiFileUpload" accept=".png,.json" multiple />
                 </div>
                 <div class="mb-2">
                   <button id="unloadCustomLivery" class="btn btn-outline-secondary btn-sm">Unload Custom Livery Files</button>
                 </div>
               </div>
             </div>
           </div>
-          
+
           <div class="col-md-3">
             <div class="card">
               <div class="card-header p-2">Info</div>
               <div class="card-body p-2">
                 <p class="mb-1">App made by blumlaut</p>
                 <p class="mb-1"><a href="https://github.com/blumlaut/acc-livery-viewer" class="text-decoration-none">https://github.com/blumlaut/acc-livery-viewer</a></p>
                 <p class="mb-1">Cubemaps made by Emil Persson, aka Humus</p>
                 <p class="mb-1"><a href="http://www.humus.name" class="text-decoration-none">http://www.humus.name</a></p>
               </div>
             </div>
           </div>
       </div>
 
-        <div id="liveryLayer" class="row">
+          <div id="liveryLayer" class="row">
             <div class="col-md-3">
               <div class="card">
                 <div class="card-header p-2">Layer 1</div>
                 <div class="card-body p-2">
                   <div class="row">
                     <div class="col-6">
                       <color-picker id="layer1Color" color-id="237"></color-picker>
                     </div>
                     <div class="col-6">
                       <select class="form-select" id="layer1Material">
                         <option value="glossy">glossy</option>
                         <option value="matte">matte</option>
                         <option value="satin">satin</option>
                         <option value="satinMetallic">satinMetallic</option>
                         <option value="metallic">metallic</option>
                         <option value="chrome">chrome</option>
                       </select>
                     </div>
                   </div>
                 </div>
               </div>
             </div>
             <div class="col-md-3">
               <div class="card">
                 <div class="card-header p-2">Layer 2</div>
@@ -169,46 +172,143 @@
               </div>
             </div>
             <div class="col-md-3">
               <div class="card">
                 <div class="card-header p-2">Rims</div>
                 <div class="card-body p-2">
                   <div class="row">
                     <div class="col-6">
                       <color-picker id="rimColor" color-id="341"></color-picker>
                     </div>
                     <div class="col-6">
                       <select class="form-select" id="rimMaterial">
                         <option value="glossy">glossy</option>
                         <option value="matte">matte</option>
                         <option value="satin">satin</option>
                         <option value="satinMetallic">satinMetallic</option>
                         <option value="metallic">metallic</option>
                         <option value="chrome">chrome</option>
                       </select>
                     </div>
                   </div>
                 </div>
               </div>
             </div>
           </div>
-          
-    </div>
-    
-    <div id="dropZone">
-      <div id="modelContainer">
-          <div id="overlay">
-              <p id="models">Models: </p>
-              <p id="textures">Textures: </p>
-              <p id="polygons">Polygons: </p>
-              <p id="drawCalls">Draw Calls: </p>
-              <br>
-              <p id="loadedCar">Car: </p>
-              <p id="skinId">Skin ID: </p>
-              <p id="skinColours">Colours: </p>
 
+        </div>
+
+        <div id="dropZone" class="workspace">
+          <div class="workspace-split">
+            <div class="viewer-pane">
+              <div id="modelContainer">
+                  <div id="overlay">
+                      <p id="models">Models: </p>
+                      <p id="textures">Textures: </p>
+                      <p id="polygons">Polygons: </p>
+                      <p id="drawCalls">Draw Calls: </p>
+                      <br>
+                      <p id="loadedCar">Car: </p>
+                      <p id="skinId">Skin ID: </p>
+                      <p id="skinColours">Colours: </p>
+
+                    </div>
+              </div>
+            </div>
+            <div class="canvas-pane">
+              <canvas id="hiddenCanvas" class="editor-canvas" tabindex="0" aria-label="Livery editing canvas"></canvas>
             </div>
+          </div>
+        </div>
       </div>
+
+      <aside id="editorPanel" class="editor-panel" aria-hidden="true">
+        <div class="editor-panel-content">
+          <button id="editorPanelClose" class="editor-panel-close" aria-label="Close editor panel">&times;</button>
+          <h2 class="editor-panel-title">Editor</h2>
+
+          <section class="editor-section">
+            <h3 class="editor-section-title">Layers</h3>
+            <p class="editor-section-note">Decals and sponsors base layers are locked.</p>
+            <ul id="layerList" class="layer-list"></ul>
+            <div class="layer-actions">
+              <button id="createLayerButton" class="btn btn-sm btn-primary">New Layer</button>
+              <button id="mergeLayerButton" class="btn btn-sm btn-outline-secondary">Merge Down</button>
+            </div>
+          </section>
+
+          <section class="editor-section">
+            <h3 class="editor-section-title">Painting Tools</h3>
+            <div class="form-group">
+              <label for="toolSelect" class="form-label">Active Tool</label>
+              <select id="toolSelect" class="form-select form-select-sm">
+                <option value="brush">Brush</option>
+                <option value="eraser">Eraser</option>
+                <option value="fill">Fill</option>
+              </select>
+            </div>
+            <div class="brush-settings">
+              <label for="brushSizeRange" class="form-label">Brush Size</label>
+              <input type="range" id="brushSizeRange" min="1" max="200" value="50">
+              <label for="brushOpacityRange" class="form-label">Opacity</label>
+              <input type="range" id="brushOpacityRange" min="0" max="1" step="0.01" value="1">
+              <label for="brushHardnessRange" class="form-label">Hardness</label>
+              <input type="range" id="brushHardnessRange" min="0" max="1" step="0.05" value="0.8">
+            </div>
+          </section>
+
+          <section class="editor-section">
+            <h3 class="editor-section-title">Mirror</h3>
+            <div class="form-check form-switch">
+              <input class="form-check-input" type="checkbox" id="mirrorToggle">
+              <label class="form-check-label" for="mirrorToggle">Enable Mirror Painting</label>
+            </div>
+            <div class="form-group mt-2">
+              <label for="mirrorAxisSelect" class="form-label">Axis</label>
+              <select id="mirrorAxisSelect" class="form-select form-select-sm">
+                <option value="x">X</option>
+                <option value="y">Y</option>
+                <option value="z">Z</option>
+              </select>
+            </div>
+            <div class="form-group mt-2">
+              <label for="mirrorModeSelect" class="form-label">Mode</label>
+              <select id="mirrorModeSelect" class="form-select form-select-sm">
+                <option value="mirror">Mirror</option>
+                <option value="flip">Flip</option>
+              </select>
+            </div>
+          </section>
+
+          <section class="editor-section">
+            <h3 class="editor-section-title">Canvas Display</h3>
+            <div class="form-check form-switch">
+              <input class="form-check-input" type="checkbox" id="uvBackgroundToggle" checked>
+              <label class="form-check-label" for="uvBackgroundToggle">Show UV Template</label>
+            </div>
+          </section>
+
+          <section class="editor-section">
+            <h3 class="editor-section-title">Stickers</h3>
+            <label for="stickerUploadInput" class="form-label">Upload Sticker</label>
+            <input type="file" id="stickerUploadInput" class="form-control form-control-sm" accept="image/png,image/jpeg,image/webp">
+          </section>
+
+          <section class="editor-section">
+            <h3 class="editor-section-title">Text</h3>
+            <form id="textEntryForm" class="text-entry-form">
+              <label for="textEntryInput" class="form-label">Add Text Layer</label>
+              <input type="text" id="textEntryInput" class="form-control form-control-sm" placeholder="Enter text" required>
+              <button type="submit" class="btn btn-sm btn-primary mt-2">Add Text</button>
+            </form>
+          </section>
+
+          <section class="editor-section">
+            <h3 class="editor-section-title">Export</h3>
+            <button id="exportLiveryButton" class="btn btn-success btn-sm w-100">Export Livery</button>
+          </section>
+        </div>
+      </aside>
     </div>
-	<canvas id="hiddenCanvas" ></canvas>
+
 </body>
 </html>
diff --git a/main.js b/main.js
index bfc4e1e7e4d6c327395c05c8ded9fb5fbe3e41da..7d142edf959147e81416fb3593cbe9c1532af85d 100644
--- a/main.js
+++ b/main.js
@@ -1,47 +1,49 @@
 import * as THREE from 'three';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
 import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
 import { GTAOPass } from 'three/addons/postprocessing/GTAOPass.js';
 import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
 import { SMAAPass } from 'three/addons/postprocessing/SMAAPass.js';
 
 import { AppState } from './src/state.js';
 import { EnvironmentManager } from './src/environmentManager.js';
 import { MaterialManager } from './src/materialManager.js';
 import { ModelLoader } from './src/modelLoader.js';
 import { UIController } from './src/uiController.js';
+import { LiveryEditor } from './src/liveryEditor.js';
 
 window.viewerReady = false;
 
 const appState = new AppState();
 const environmentManager = new EnvironmentManager(appState);
 const materialManager = new MaterialManager(appState);
 const modelLoader = new ModelLoader(appState, materialManager);
 materialManager.setModelLoader(modelLoader);
-const uiController = new UIController(appState, modelLoader, materialManager, environmentManager);
+const liveryEditor = new LiveryEditor(appState, materialManager);
+const uiController = new UIController(appState, modelLoader, materialManager, environmentManager, liveryEditor);
 
 const overlayElements = {
     models: document.getElementById('models'),
     textures: document.getElementById('textures'),
     polygons: document.getElementById('polygons'),
     drawCalls: document.getElementById('drawCalls'),
     loadedCar: document.getElementById('loadedCar'),
     skinId: document.getElementById('skinId'),
     skinColours: document.getElementById('skinColours'),
 };
 
 // Animation throttling variables
 let lastRenderTime = 0;
 let overlayUpdateCounter = 0;
 const overlayUpdateInterval = 10; // Update overlay every 10 frames
 
 // Add memory monitoring and cleanup triggers
 function setupMemoryMonitoring() {
     // Periodic memory check
     setInterval(() => {
         const stats = appState.resourceStats;
         if (stats.textures > 100 || stats.geometries > 1000 || stats.materials > 500) {
             console.warn('High resource usage detected:', stats);
             // Trigger cleanup if needed
             if (stats.textures > 500) {
@@ -78,50 +80,51 @@ function cleanupAllResources() {
                     object.geometry.dispose();
                 }
                 if (object.material) {
                     if (Array.isArray(object.material)) {
                         object.material.forEach(material => material.dispose());
                     } else {
                         object.material.dispose();
                     }
                 }
             }
         });
     }
     
     // Cleanup renderer resources
     if (appState.renderer) {
         appState.renderer.dispose();
     }
     
     // Reset state
     appState.cleanupResources();
     
     console.log('Resource cleanup completed');
 }
 
 async function init() {
+    await liveryEditor.initialize();
     await uiController.initialize();
     setupThreeScene();
     if (uiController.cubemapSelector && appState.currentSkybox) {
         uiController.cubemapSelector.value = appState.currentSkybox;
     }
     if (uiController.skyboxToggle) {
         uiController.skyboxToggle.checked = appState.skyboxEnabled;
     }
     environmentManager.applySkybox(appState.currentSkybox);
 
     const initialModel = appState.currentModelPath || Object.keys(modelFiles)[0];
     appState.setCurrentModelPath(initialModel);
     uiController.setModelSelection(initialModel);
     uiController.populateLiverySelector(initialModel);
 
     const defaultLivery = appState.currentLivery || modelLoader.getDefaultLivery(initialModel);
     if (defaultLivery) {
         appState.setCurrentLivery(defaultLivery);
         uiController.setLiverySelection(defaultLivery);
     }
 
     await modelLoader.loadModel(initialModel);
     setupMemoryMonitoring();
     animate();
 }
diff --git a/src/liveryEditor.js b/src/liveryEditor.js
new file mode 100644
index 0000000000000000000000000000000000000000..2cadeb1c09cd79c52ab3a3d2ea891c3fb1a9dcc1
--- /dev/null
+++ b/src/liveryEditor.js
@@ -0,0 +1,1481 @@
+const DEFAULT_CANVAS_SIZE = 2048;
+const MIRROR_AXIS = { x: 'x', y: 'y', z: 'z' };
+
+export class LiveryEditor {
+    constructor(state, materialManager) {
+        this.state = state;
+        this.materialManager = materialManager;
+
+        this.canvas = null;
+        this.ctx = null;
+        this.layerSurfaces = new Map();
+        this.compositeSurfaces = new Map();
+        this.imageCache = new Map();
+        this.measureContext = document.createElement('canvas').getContext('2d');
+
+        this.brushSettings = {
+            size: 50,
+            opacity: 1,
+            hardness: 0.8,
+            color: '#ffffff',
+        };
+        this.activeTool = this.state.activeTool || 'brush';
+        this.mirrorSettings = { ...this.state.symmetrySettings };
+        this.pointerState = null;
+        this.templateImage = null;
+        this.pendingSnapshot = null;
+        this.selection = null;
+        this.selectionHandles = [];
+        this.showTemplate = true;
+        this.handleRadius = 9;
+        this.rotationHandleOffset = 48;
+        this.currentCursor = 'default';
+
+        this._handleEditorEvent = this._handleEditorEvent.bind(this);
+        this._onPointerDown = this._onPointerDown.bind(this);
+        this._onPointerMove = this._onPointerMove.bind(this);
+        this._onPointerUp = this._onPointerUp.bind(this);
+        this._onBaseTextureChange = this._onBaseTextureChange.bind(this);
+        this._onBaseLayersReady = this._onBaseLayersReady.bind(this);
+    }
+
+    async initialize() {
+        this.canvas = document.getElementById('hiddenCanvas');
+        if (!this.canvas) {
+            console.warn('LiveryEditor: hidden canvas element is missing.');
+            return;
+        }
+        this.ctx = this.canvas.getContext('2d');
+        this._ensureCanvasSize(DEFAULT_CANVAS_SIZE, DEFAULT_CANVAS_SIZE);
+        this._setCanvasCursor('default');
+
+        this.state.addEditorListener(this._handleEditorEvent);
+        this.state.addCleanupCallback(() => this.reset());
+
+        this._attachInputHandlers();
+        document.addEventListener('editor:exportLivery', () => this.exportLivery());
+        document.addEventListener('editor:baseTextureChanged', this._onBaseTextureChange);
+        document.addEventListener('editor:baseLayersReady', this._onBaseLayersReady);
+
+        this.ensureBaseLayers();
+        this.state.layers.forEach((layer) => this.ensureLayerSurface(layer));
+        await this._loadTemplateFromSelection();
+        this.renderComposite();
+    }
+
+    reset() {
+        this.layerSurfaces.forEach((surface) => {
+            surface.canvas.width = 0;
+            surface.canvas.height = 0;
+        });
+        this.layerSurfaces.clear();
+        this.compositeSurfaces.forEach((surface) => {
+            surface.canvas.width = 0;
+            surface.canvas.height = 0;
+        });
+        this.compositeSurfaces.clear();
+        this.pointerState = null;
+        this.pendingSnapshot = null;
+        this.templateImage = null;
+        this.selection = null;
+        this.selectionHandles = [];
+        this._ensureCanvasSize(DEFAULT_CANVAS_SIZE, DEFAULT_CANVAS_SIZE);
+        this._setCanvasCursor('default');
+        if (this.materialManager) {
+            this.materialManager.updateEditorOverlay('decals', null);
+            this.materialManager.updateEditorOverlay('sponsors', null);
+        }
+    }
+
+    setActiveLayer(layerId) {
+        this.pointerState = null;
+        if (this.selection && this.selection.layerId !== layerId) {
+            this._clearSelection();
+        }
+        if (layerId) {
+            this.ensureLayerSurface(this.state.getLayerById(layerId));
+        }
+    }
+
+    setActiveTool(tool) {
+        this.activeTool = tool;
+    }
+
+    updateBrushSetting(key, value) {
+        this.brushSettings = {
+            ...this.brushSettings,
+            [key]: value,
+        };
+    }
+
+    setMirrorSettings(settings = {}) {
+        this.mirrorSettings = {
+            ...this.mirrorSettings,
+            ...settings,
+        };
+    }
+
+    setTemplateVisibility(visible) {
+        const nextValue = Boolean(visible);
+        if (this.showTemplate === nextValue) {
+            return;
+        }
+        this.showTemplate = nextValue;
+        this.renderComposite();
+    }
+
+    isTemplateVisible() {
+        return Boolean(this.showTemplate);
+    }
+
+    ensureBaseLayers() {
+        const decalsBaseId = this.state.baseLayers?.decals;
+        const sponsorsBaseId = this.state.baseLayers?.sponsors;
+
+        const hasDecalsBase = decalsBaseId && this.state.getLayerById(decalsBaseId);
+        const hasSponsorsBase = sponsorsBaseId && this.state.getLayerById(sponsorsBaseId);
+
+        if (!hasDecalsBase) {
+            this.state.insertLayer({
+                name: 'Decals Base',
+                type: 'base',
+                locked: true,
+                isBase: true,
+                baseType: 'decals',
+                metadata: { items: [] },
+            }, 0);
+        }
+
+        if (!hasSponsorsBase) {
+            const targetIndex = this.state.layers.length > 0 ? 1 : 0;
+            this.state.insertLayer({
+                name: 'Sponsors Base',
+                type: 'base',
+                locked: true,
+                isBase: true,
+                baseType: 'sponsors',
+                metadata: { items: [] },
+            }, targetIndex);
+        }
+    }
+
+    ensureLayerSurface(layer) {
+        if (!layer) {
+            return null;
+        }
+
+        if (!layer.metadata || typeof layer.metadata !== 'object') {
+            layer.metadata = {};
+        }
+        if (!Array.isArray(layer.metadata.items)) {
+            layer.metadata.items = [];
+        }
+
+        let surface = this.layerSurfaces.get(layer.id);
+        if (!surface) {
+            const canvas = document.createElement('canvas');
+            canvas.width = this.canvas.width;
+            canvas.height = this.canvas.height;
+            surface = {
+                canvas,
+                ctx: canvas.getContext('2d'),
+                items: [],
+            };
+            this.layerSurfaces.set(layer.id, surface);
+        } else if (surface.canvas.width !== this.canvas.width || surface.canvas.height !== this.canvas.height) {
+            surface.canvas.width = this.canvas.width;
+            surface.canvas.height = this.canvas.height;
+        }
+
+        this._hydrateLayer(layer);
+        return surface;
+    }
+
+    _ensureCompositeSurface(type) {
+        if (!type) {
+            return null;
+        }
+        let surface = this.compositeSurfaces.get(type);
+        if (!surface) {
+            const canvas = document.createElement('canvas');
+            canvas.width = this.canvas?.width || DEFAULT_CANVAS_SIZE;
+            canvas.height = this.canvas?.height || DEFAULT_CANVAS_SIZE;
+            surface = {
+                canvas,
+                ctx: canvas.getContext('2d')
+            };
+            this.compositeSurfaces.set(type, surface);
+        } else if (this.canvas && (surface.canvas.width !== this.canvas.width || surface.canvas.height !== this.canvas.height)) {
+            surface.canvas.width = this.canvas.width;
+            surface.canvas.height = this.canvas.height;
+        }
+        return surface;
+    }
+
+    _getOverlayTargetsForLayer(layer) {
+        if (!layer) {
+            return ['decals'];
+        }
+        const metadataTarget = layer.metadata?.targetOverlay || layer.metadata?.overlay;
+        const baseType = (layer.baseType || layer.type || metadataTarget || '').toLowerCase();
+
+        if (metadataTarget === 'decals' || metadataTarget === 'sponsors') {
+            return [metadataTarget];
+        }
+
+        if (baseType === 'sponsors' || baseType === 'sponsorsbase') {
+            return ['sponsors'];
+        }
+
+        return ['decals'];
+    }
+
+    removeLayer(layerId) {
+        if (this.selection?.layerId === layerId) {
+            this._clearSelection(false);
+        }
+        if (this.layerSurfaces.has(layerId)) {
+            this.layerSurfaces.delete(layerId);
+        }
+    }
+
+    mergeLayers(targetLayerId, sourceLayerId) {
+        const targetLayer = this.state.getLayerById(targetLayerId);
+        const sourceLayer = this.state.getLayerById(sourceLayerId);
+        if (!targetLayer || !sourceLayer) {
+            return;
+        }
+
+        this.ensureLayerSurface(targetLayer);
+        this.ensureLayerSurface(sourceLayer);
+
+        if (!Array.isArray(targetLayer.metadata.items)) {
+            targetLayer.metadata.items = [];
+        }
+        if (Array.isArray(sourceLayer.metadata.items) && sourceLayer.metadata.items.length) {
+            sourceLayer.metadata.items.forEach((item) => {
+                targetLayer.metadata.items.push(item);
+            });
+        }
+
+        this.layerSurfaces.delete(sourceLayerId);
+        this._hydrateLayer(targetLayer);
+        this.renderLayer(targetLayerId);
+        this.renderComposite();
+    }
+
+    async addStickerToLayer(layerId, src, options = {}) {
+        if (!layerId || !src) {
+            return null;
+        }
+        const layer = this.state.getLayerById(layerId);
+        if (!layer) {
+            return null;
+        }
+        const image = await this._loadImage(src).catch(() => null);
+        if (!image) {
+            return null;
+        }
+
+        const sticker = {
+            id: this._generateItemId('sticker'),
+            type: 'sticker',
+            src,
+            width: options.width || image.width,
+            height: options.height || image.height,
+            opacity: options.opacity ?? 1,
+            transform: {
+                x: options.x ?? this.canvas.width / 2,
+                y: options.y ?? this.canvas.height / 2,
+                scaleX: options.scale ?? 1,
+                scaleY: options.scale ?? 1,
+                rotation: options.rotation ?? 0,
+            },
+        };
+
+        layer.metadata.items.push(sticker);
+        const surface = this.ensureLayerSurface(layer);
+        const runtime = this._createRuntimeItem(layer.id, sticker);
+        surface.items.push(runtime);
+
+        const mirrored = this._maybeCreateMirroredItem(layer, sticker);
+        if (mirrored) {
+            layer.metadata.items.push(mirrored);
+            surface.items.push(this._createRuntimeItem(layer.id, mirrored));
+        }
+
+        this.renderLayer(layer.id);
+        this.renderComposite();
+        this.state.markLayerDirty(layer.id);
+        return sticker;
+    }
+
+    addTextToLayer(layerId, text, options = {}) {
+        if (!layerId || !text) {
+            return null;
+        }
+        const layer = this.state.getLayerById(layerId);
+        if (!layer) {
+            return null;
+        }
+
+        const textItem = {
+            id: this._generateItemId('text'),
+            type: 'text',
+            content: text,
+            font: options.font || 'Arial',
+            size: options.size || 72,
+            color: options.color || '#ffffff',
+            opacity: options.opacity ?? 1,
+            align: options.align || 'center',
+            baseline: options.baseline || 'middle',
+            transform: {
+                x: options.x ?? this.canvas.width / 2,
+                y: options.y ?? this.canvas.height / 2,
+                scaleX: options.scaleX ?? 1,
+                scaleY: options.scaleY ?? 1,
+                rotation: options.rotation ?? 0,
+            },
+        };
+
+        layer.metadata.items.push(textItem);
+        const surface = this.ensureLayerSurface(layer);
+        surface.items.push(this._createRuntimeItem(layer.id, textItem));
+
+        const mirrored = this._maybeCreateMirroredText(layer, textItem);
+        if (mirrored) {
+            layer.metadata.items.push(mirrored);
+            surface.items.push(this._createRuntimeItem(layer.id, mirrored));
+        }
+
+        this.renderLayer(layer.id);
+        this.renderComposite();
+        this.state.markLayerDirty(layer.id);
+        return textItem;
+    }
+
+    renderLayer(layerId, options = {}) {
+        const surface = this.layerSurfaces.get(layerId);
+        if (!surface) {
+            return;
+        }
+        const ctx = surface.ctx;
+        ctx.clearRect(0, 0, surface.canvas.width, surface.canvas.height);
+        surface.items.forEach((item) => {
+            this._renderItem(ctx, item);
+        });
+
+        if (options.previewStroke) {
+            this._renderStroke(ctx, options.previewStroke);
+        }
+        if (options.previewMirrors) {
+            options.previewMirrors.forEach((mirror) => this._renderStroke(ctx, mirror));
+        }
+    }
+
+    renderComposite() {
+        if (!this.canvas || !this.ctx) {
+            return;
+        }
+        this._renderBaseComposite(this.ctx, { includeTemplate: this.showTemplate });
+        const overlayOutputs = this._renderOverlayComposites();
+        this._drawSelectionOverlay(this.ctx);
+        const appliedToViewer = this._syncCompositeWithViewer(overlayOutputs);
+        this.state.markLayerDirty();
+        document.dispatchEvent(new CustomEvent('editor:canvasUpdated', {
+            detail: {
+                origin: 'liveryEditor',
+                applied: appliedToViewer,
+                canvas: this.canvas,
+                overlays: Object.fromEntries(
+                    Object.entries(overlayOutputs)
+                        .filter(([, surface]) => Boolean(surface))
+                        .map(([type, surface]) => [type, surface.canvas])
+                )
+            }
+        }));
+    }
+
+    _renderBaseComposite(ctx, options = {}) {
+        if (!ctx || !this.canvas) {
+            return;
+        }
+        const { includeTemplate = true } = options;
+        ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
+
+        if (includeTemplate && this.templateImage) {
+            ctx.drawImage(this.templateImage, 0, 0, this.canvas.width, this.canvas.height);
+        } else {
+            this._drawFallbackBackground(ctx);
+        }
+
+        const layers = Array.isArray(this.state.layers) ? this.state.layers : [];
+        layers.forEach((layer) => {
+            if (layer.visible === false) {
+                return;
+            }
+            const surface = this.layerSurfaces.get(layer.id);
+            if (surface) {
+                ctx.drawImage(surface.canvas, 0, 0);
+            }
+        });
+    }
+
+    _renderOverlayComposites() {
+        const outputs = {
+            decals: this._ensureCompositeSurface('decals'),
+            sponsors: this._ensureCompositeSurface('sponsors')
+        };
+
+        Object.values(outputs).forEach((surface) => {
+            if (surface && surface.canvas) {
+                surface.ctx.clearRect(0, 0, surface.canvas.width, surface.canvas.height);
+            }
+        });
+
+        const layers = Array.isArray(this.state.layers) ? this.state.layers : [];
+        layers.forEach((layer) => {
+            if (layer?.visible === false) {
+                return;
+            }
+            const surface = this.layerSurfaces.get(layer.id);
+            if (!surface) {
+                return;
+            }
+            const targets = this._getOverlayTargetsForLayer(layer);
+            targets.forEach((target) => {
+                const compositeSurface = outputs[target];
+                if (compositeSurface) {
+                    compositeSurface.ctx.drawImage(surface.canvas, 0, 0);
+                }
+            });
+        });
+
+        return outputs;
+    }
+
+    _syncCompositeWithViewer(outputs) {
+        if (!this.materialManager || !outputs) {
+            return false;
+        }
+        let applied = false;
+        Object.entries(outputs).forEach(([type, surface]) => {
+            const canvas = surface?.canvas && surface.canvas.width && surface.canvas.height
+                ? surface.canvas
+                : null;
+            this.materialManager.updateEditorOverlay(type, canvas);
+            applied = true;
+        });
+        return applied;
+    }
+
+    exportLivery() {
+        if (!this.canvas) {
+            return;
+        }
+        const exportCanvas = document.createElement('canvas');
+        exportCanvas.width = this.canvas.width;
+        exportCanvas.height = this.canvas.height;
+        const exportCtx = exportCanvas.getContext('2d');
+        this._renderBaseComposite(exportCtx, { includeTemplate: this.showTemplate });
+        const dataUrl = exportCanvas.toDataURL('image/png');
+        const link = document.createElement('a');
+        link.href = dataUrl;
+        link.download = 'livery.png';
+        link.click();
+    }
+
+    _handleEditorEvent(event) {
+        switch (event.type) {
+            case 'reset':
+                this.reset();
+                this.ensureBaseLayers();
+                break;
+            case 'stateApplied':
+                this.layerSurfaces.clear();
+                this.state.layers.forEach((layer) => this.ensureLayerSurface(layer));
+                this.renderComposite();
+                break;
+            case 'layerInserted':
+                if (event.detail?.layer?.id) {
+                    const layer = this.state.getLayerById(event.detail.layer.id);
+                    this.ensureLayerSurface(layer);
+                    this.renderLayer(layer.id);
+                    this.renderComposite();
+                }
+                break;
+            case 'layerDeleted':
+                if (event.detail?.layerId) {
+                    this.removeLayer(event.detail.layerId);
+                    this.renderComposite();
+                }
+                break;
+            case 'layersMerged':
+                if (event.detail?.targetLayerId && event.detail?.sourceLayerId) {
+                    const targetLayer = this.state.getLayerById(event.detail.targetLayerId);
+                    if (targetLayer) {
+                        this._hydrateLayer(targetLayer);
+                        this.renderLayer(targetLayer.id);
+                        this.renderComposite();
+                    }
+                    this.removeLayer(event.detail.sourceLayerId);
+                }
+                break;
+            case 'activeLayerChanged':
+                this.setActiveLayer(event.detail?.layerId ?? null);
+                break;
+            case 'activeToolChanged':
+                this.setActiveTool(event.detail?.tool ?? this.state.activeTool);
+                break;
+            case 'symmetryChanged':
+                if (event.detail?.settings) {
+                    this.setMirrorSettings(event.detail.settings);
+                }
+                break;
+            default:
+                break;
+        }
+    }
+
+    async _loadTemplateFromSelection() {
+        const modelPath = this.state.currentModelPath;
+        const liveryId = this.state.currentLivery;
+        const liveryData = modelPath && liveryId ? globalThis.baseLiveries?.[modelPath]?.[liveryId] : null;
+
+        let templateSrc = null;
+        let decalsSrc = null;
+        let sponsorsSrc = null;
+
+        if (liveryData?.path) {
+            const basePath = `models/${modelPath}/skins/custom/${liveryData.path}`;
+            templateSrc = `${basePath}/EXT_Skin_Custom.png`;
+            if (liveryData.hasDecals) {
+                decalsSrc = `${basePath}/EXT_Skin_Decals.png`;
+            }
+            if (liveryData.sponsor) {
+                sponsorsSrc = `${basePath}/EXT_Skin_Sponsors.png`;
+            }
+        }
+
+        await this._loadTemplate(templateSrc);
+        await this._applyBaseTexture('decals', decalsSrc || templateSrc);
+        await this._applyBaseTexture('sponsors', sponsorsSrc);
+        this.renderComposite();
+    }
+
+    async _loadTemplate(src) {
+        if (!this.canvas) {
+            return;
+        }
+        if (!src) {
+            this.templateImage = null;
+            this._ensureCanvasSize(DEFAULT_CANVAS_SIZE, DEFAULT_CANVAS_SIZE);
+            return;
+        }
+        const image = await this._loadImage(src).catch(() => null);
+        if (image) {
+            this.templateImage = image;
+            this._ensureCanvasSize(image.width, image.height);
+        } else {
+            this.templateImage = null;
+            this._ensureCanvasSize(DEFAULT_CANVAS_SIZE, DEFAULT_CANVAS_SIZE);
+        }
+    }
+
+    async _applyBaseTexture(type, src) {
+        const layerId = type === 'sponsors' ? this.state.baseLayers?.sponsors : this.state.baseLayers?.decals;
+        if (!layerId) {
+            return;
+        }
+        const layer = this.state.getLayerById(layerId);
+        if (!layer) {
+            return;
+        }
+        const surface = this.ensureLayerSurface(layer);
+        const items = layer.metadata.items;
+        const existingIndex = items.findIndex((item) => item.role === type && item.type === 'image');
+
+        if (!src) {
+            if (existingIndex !== -1) {
+                items.splice(existingIndex, 1);
+            }
+            this._hydrateLayer(layer);
+            this.renderLayer(layer.id);
+            return;
+        }
+
+        const baseItem = {
+            id: this._generateItemId(`${type}-base`),
+            type: 'image',
+            role: type,
+            src,
+            width: this.canvas.width,
+            height: this.canvas.height,
+            opacity: 1,
+            transform: {
+                x: this.canvas.width / 2,
+                y: this.canvas.height / 2,
+                scaleX: 1,
+                scaleY: 1,
+                rotation: 0,
+            },
+        };
+
+        if (existingIndex !== -1) {
+            items.splice(existingIndex, 1, baseItem);
+        } else {
+            items.unshift(baseItem);
+        }
+
+        this.ensureLayerSurface(layer);
+        const runtime = this._createRuntimeItem(layer.id, baseItem);
+        const runtimeIndex = surface.items.findIndex((item) => item?.data?.role === type && item.data.type === 'image');
+        if (runtimeIndex !== -1) {
+            surface.items.splice(runtimeIndex, 1, runtime);
+        } else {
+            surface.items.unshift(runtime);
+        }
+        this.renderLayer(layer.id);
+    }
+
+    _hydrateLayer(layer) {
+        const surface = this.layerSurfaces.get(layer.id);
+        if (!surface) {
+            return;
+        }
+        surface.items = [];
+        layer.metadata.items.forEach((item) => {
+            surface.items.push(this._createRuntimeItem(layer.id, item));
+        });
+    }
+
+    _createRuntimeItem(layerId, item) {
+        const runtime = {
+            type: item.type,
+            data: item,
+        };
+        item.id = item.id || this._generateItemId(item.type || 'item');
+
+        if (!item.transform) {
+            item.transform = {
+                x: this.canvas.width / 2,
+                y: this.canvas.height / 2,
+                scaleX: 1,
+                scaleY: 1,
+                rotation: 0,
+            };
+        }
+
+        if (item.type === 'sticker' || item.type === 'image') {
+            runtime.imagePromise = this._loadImage(item.src).then((image) => {
+                runtime.image = image;
+                if (!item.width) {
+                    item.width = image.width;
+                }
+                if (!item.height) {
+                    item.height = image.height;
+                }
+                this.renderLayer(layerId);
+                this.renderComposite();
+                return image;
+            }).catch(() => null);
+        }
+
+        if (item.type === 'text') {
+            this.measureContext.font = `${item.size || 48}px ${item.font || 'Arial'}`;
+            const metrics = this.measureContext.measureText(item.content || '');
+            item.metrics = {
+                width: metrics.width,
+                actualBoundingBoxAscent: metrics.actualBoundingBoxAscent,
+                actualBoundingBoxDescent: metrics.actualBoundingBoxDescent,
+            };
+        }
+
+        if (item.type === 'stroke' && Array.isArray(item.points)) {
+            runtime.stroke = item;
+        }
+
+        return runtime;
+    }
+
+    _renderItem(ctx, item) {
+        const data = item.data;
+        if (!data) {
+            return;
+        }
+        if (data.type === 'stroke') {
+            this._renderStroke(ctx, data);
+            return;
+        }
+        if (data.type === 'text') {
+            this._renderText(ctx, data);
+            return;
+        }
+        if (data.type === 'sticker' || data.type === 'image') {
+            if (item.image) {
+                this._renderImage(ctx, data, item.image);
+            }
+            return;
+        }
+    }
+
+    _renderImage(ctx, data, image) {
+        const transform = data.transform || {};
+        const width = data.width || image.width;
+        const height = data.height || image.height;
+        ctx.save();
+        ctx.globalAlpha = data.opacity ?? 1;
+        ctx.translate(transform.x ?? 0, transform.y ?? 0);
+        ctx.rotate(transform.rotation || 0);
+        ctx.scale(transform.scaleX ?? 1, transform.scaleY ?? 1);
+        ctx.drawImage(image, -width / 2, -height / 2, width, height);
+        ctx.restore();
+    }
+
+    _renderText(ctx, data) {
+        const transform = data.transform || {};
+        ctx.save();
+        ctx.translate(transform.x ?? 0, transform.y ?? 0);
+        ctx.rotate(transform.rotation || 0);
+        ctx.scale(transform.scaleX ?? 1, transform.scaleY ?? 1);
+        ctx.globalAlpha = data.opacity ?? 1;
+        ctx.fillStyle = data.color || '#ffffff';
+        ctx.font = `${data.size || 48}px ${data.font || 'Arial'}`;
+        ctx.textAlign = data.align || 'center';
+        ctx.textBaseline = data.baseline || 'middle';
+        ctx.fillText(data.content || '', 0, 0);
+        ctx.restore();
+    }
+
+    _renderStroke(ctx, stroke) {
+        if (!stroke.points || stroke.points.length < 1) {
+            return;
+        }
+        ctx.save();
+        ctx.lineCap = 'round';
+        ctx.lineJoin = 'round';
+        ctx.globalAlpha = stroke.opacity ?? 1;
+        ctx.lineWidth = stroke.size ?? 10;
+        if (stroke.tool === 'eraser') {
+            ctx.globalCompositeOperation = 'destination-out';
+            ctx.strokeStyle = 'rgba(0,0,0,1)';
+            ctx.shadowBlur = 0;
+        } else {
+            ctx.globalCompositeOperation = 'source-over';
+            ctx.strokeStyle = stroke.color || this.brushSettings.color;
+            const softness = Math.min(1, Math.max(0, 1 - (stroke.hardness ?? this.brushSettings.hardness)));
+            ctx.shadowBlur = softness * (stroke.size ?? 10) * 0.5;
+            ctx.shadowColor = ctx.strokeStyle;
+        }
+        const [first, ...rest] = stroke.points;
+        ctx.beginPath();
+        ctx.moveTo(first.x, first.y);
+        rest.forEach((point) => {
+            ctx.lineTo(point.x, point.y);
+        });
+        ctx.stroke();
+        ctx.restore();
+    }
+
+    _drawFallbackBackground(ctx = this.ctx) {
+        if (!ctx) {
+            return;
+        }
+        const canvasWidth = ctx.canvas?.width ?? this.canvas?.width ?? 0;
+        const canvasHeight = ctx.canvas?.height ?? this.canvas?.height ?? 0;
+        const size = 64;
+        for (let y = 0; y < canvasHeight; y += size) {
+            for (let x = 0; x < canvasWidth; x += size) {
+                const isDark = ((x / size) + (y / size)) % 2 === 0;
+                ctx.fillStyle = isDark ? '#2c2c2c' : '#3a3a3a';
+                ctx.fillRect(x, y, size, size);
+            }
+        }
+        ctx.strokeStyle = 'rgba(255,255,255,0.05)';
+        ctx.lineWidth = 1;
+        for (let x = 0; x <= canvasWidth; x += size) {
+            ctx.beginPath();
+            ctx.moveTo(x, 0);
+            ctx.lineTo(x, canvasHeight);
+            ctx.stroke();
+        }
+        for (let y = 0; y <= canvasHeight; y += size) {
+            ctx.beginPath();
+            ctx.moveTo(0, y);
+            ctx.lineTo(canvasWidth, y);
+            ctx.stroke();
+        }
+    }
+
+    _attachInputHandlers() {
+        if (!this.canvas) {
+            return;
+        }
+        this.canvas.addEventListener('pointerdown', this._onPointerDown);
+        this.canvas.addEventListener('pointermove', this._onPointerMove);
+        window.addEventListener('pointerup', this._onPointerUp);
+        this.canvas.addEventListener('pointerleave', this._onPointerUp);
+    }
+
+    _onPointerDown(event) {
+        if (!this.canvas) {
+            return;
+        }
+        const layerId = this.state.activeLayerId || this.state.baseLayers?.decals;
+        if (!layerId) {
+            return;
+        }
+        const coords = this._getCanvasCoordinates(event);
+        const layer = this.state.getLayerById(layerId);
+        if (!layer) {
+            return;
+        }
+        const isLocked = Boolean(layer.locked);
+
+        const selectedItem = this.selection?.layerId === layerId ? this._getSelectedRuntimeItem() : null;
+        if (selectedItem && !isLocked) {
+            const handle = this._hitTestHandles(coords);
+            if (handle) {
+                this.pendingSnapshot = this.state.captureEditorState();
+                this.pointerState = {
+                    mode: handle.type === 'rotate' ? 'rotate' : 'scale',
+                    item: selectedItem,
+                    layerId,
+                    startX: coords.x,
+                    startY: coords.y,
+                    initialTransform: { ...selectedItem.data.transform },
+                    rotationOffset: handle.type === 'rotate'
+                        ? this._computeRotationOffset(selectedItem.data.transform, coords.x, coords.y)
+                        : null,
+                    mirrorItem: this._findMirrorItem(layerId, selectedItem),
+                    handle,
+                    baseWidth: this._getItemWidth(selectedItem) || 1,
+                    baseHeight: this._getItemHeight(selectedItem) || 1,
+                    scaleSignX: (selectedItem.data.transform?.scaleX ?? 1) >= 0 ? 1 : -1,
+                    scaleSignY: (selectedItem.data.transform?.scaleY ?? 1) >= 0 ? 1 : -1,
+                };
+                this._setCanvasCursor('grabbing');
+                return;
+            }
+        }
+
+        const hit = this._hitTest(layerId, coords.x, coords.y);
+        if (hit) {
+            this._setSelection(layerId, hit);
+            if (isLocked) {
+                return;
+            }
+            this.pendingSnapshot = this.state.captureEditorState();
+            const mode = event.shiftKey ? 'rotate' : 'move';
+            this.pointerState = {
+                mode,
+                item: hit,
+                layerId,
+                startX: coords.x,
+                startY: coords.y,
+                initialTransform: { ...hit.data.transform },
+                rotationOffset: this._computeRotationOffset(hit.data.transform, coords.x, coords.y),
+                mirrorItem: this._findMirrorItem(layerId, hit),
+            };
+            this._setCanvasCursor('grabbing');
+            return;
+        }
+
+        this._clearSelection();
+        if (isLocked) {
+            return;
+        }
+
+        const tool = this.activeTool || this.state.activeTool || 'brush';
+        if (tool === 'brush' || tool === 'eraser') {
+            this.pendingSnapshot = this.state.captureEditorState();
+            const stroke = this._createStroke(tool, coords);
+            const mirrorStroke = this._maybeCreateMirroredStroke(stroke);
+            this.pointerState = {
+                mode: 'stroke',
+                layerId,
+                stroke,
+                mirrorStroke,
+            };
+            this.renderLayer(layerId, {
+                previewStroke: stroke,
+                previewMirrors: mirrorStroke ? [mirrorStroke] : [],
+            });
+            this.renderComposite();
+        }
+    }
+
+    _onPointerMove(event) {
+        if (!this.canvas) {
+            return;
+        }
+        const coords = this._getCanvasCoordinates(event);
+
+        if (!this.pointerState) {
+            const layerId = this.state.activeLayerId || this.state.baseLayers?.decals;
+            const layer = layerId ? this.state.getLayerById(layerId) : null;
+            this._handleHoverState(coords, layer);
+            return;
+        }
+
+        if (this.pointerState.mode === 'stroke') {
+            this.pointerState.stroke.points.push({ x: coords.x, y: coords.y });
+            if (this.pointerState.mirrorStroke) {
+                const mirroredPoint = this._mirrorPoint(coords.x, coords.y);
+                this.pointerState.mirrorStroke.points.push(mirroredPoint);
+            }
+            this.renderLayer(this.pointerState.layerId, {
+                previewStroke: this.pointerState.stroke,
+                previewMirrors: this.pointerState.mirrorStroke ? [this.pointerState.mirrorStroke] : [],
+            });
+            this.renderComposite();
+            return;
+        }
+
+        if (this.pointerState.mode === 'select') {
+            return;
+        }
+
+        if (this.pointerState.mode === 'move' && this.pointerState.item) {
+            const dx = coords.x - this.pointerState.startX;
+            const dy = coords.y - this.pointerState.startY;
+            const transform = this.pointerState.item.data.transform;
+            transform.x = this.pointerState.initialTransform.x + dx;
+            transform.y = this.pointerState.initialTransform.y + dy;
+            if (this.pointerState.mirrorItem) {
+                this._updateMirrorTransform(this.pointerState.item.data.transform, this.pointerState.mirrorItem.data.transform);
+            }
+            this.renderLayer(this.pointerState.layerId);
+            this.renderComposite();
+            this._setCanvasCursor('grabbing');
+            return;
+        }
+
+        if (this.pointerState.mode === 'rotate' && this.pointerState.item) {
+            const transform = this.pointerState.item.data.transform;
+            const dx = coords.x - transform.x;
+            const dy = coords.y - transform.y;
+            const currentAngle = Math.atan2(dy, dx);
+            const offset = this.pointerState.rotationOffset || 0;
+            let rotation = currentAngle - offset;
+            const snap = event.altKey || event.ctrlKey || event.metaKey;
+            if (snap) {
+                const increment = Math.PI / 12;
+                rotation = Math.round(rotation / increment) * increment;
+            }
+            transform.rotation = rotation;
+            if (this.pointerState.mirrorItem) {
+                this._updateMirrorTransform(transform, this.pointerState.mirrorItem.data.transform, true);
+            }
+            this.renderLayer(this.pointerState.layerId);
+            this.renderComposite();
+            this._setCanvasCursor('grabbing');
+            return;
+        }
+
+        if (this.pointerState.mode === 'scale' && this.pointerState.item && this.pointerState.handle) {
+            this._applyScaleFromPointer(coords, event.shiftKey);
+            if (this.pointerState.mirrorItem) {
+                this._updateMirrorTransform(this.pointerState.item.data.transform, this.pointerState.mirrorItem.data.transform);
+            }
+            this.renderLayer(this.pointerState.layerId);
+            this.renderComposite();
+            this._setCanvasCursor('grabbing');
+        }
+    }
+
+    _onPointerUp() {
+        if (!this.pointerState) {
+            this._setCanvasCursor('default');
+            return;
+        }
+        if (this.pointerState.mode === 'stroke') {
+            const layer = this.state.getLayerById(this.pointerState.layerId);
+            if (layer) {
+                layer.metadata.items.push(this.pointerState.stroke);
+                const surface = this.ensureLayerSurface(layer);
+                surface.items.push(this._createRuntimeItem(layer.id, this.pointerState.stroke));
+                if (this.pointerState.mirrorStroke) {
+                    layer.metadata.items.push(this.pointerState.mirrorStroke);
+                    surface.items.push(this._createRuntimeItem(layer.id, this.pointerState.mirrorStroke));
+                }
+                this.renderLayer(layer.id);
+                this.renderComposite();
+                this.state.markLayerDirty(layer.id);
+            }
+        } else if ((this.pointerState.mode === 'move' || this.pointerState.mode === 'rotate' || this.pointerState.mode === 'scale')
+            && this.pointerState.layerId) {
+            this.state.markLayerDirty(this.pointerState.layerId);
+        }
+
+        if (this.pendingSnapshot) {
+            this.state.recordUndoState(this.pendingSnapshot);
+            this.pendingSnapshot = null;
+        }
+        this.pointerState = null;
+        this._setCanvasCursor('default');
+    }
+
+    _handleHoverState(coords, layer) {
+        if (!this.canvas) {
+            return;
+        }
+        if (layer && !layer.locked && this.selection?.layerId === layer.id) {
+            const handle = this._hitTestHandles(coords);
+            if (handle) {
+                this._setCanvasCursor(handle.cursor || 'pointer');
+                return;
+            }
+        }
+        if (!layer || layer.locked) {
+            this._setCanvasCursor('default');
+            return;
+        }
+        const hit = this._hitTest(layer.id, coords.x, coords.y);
+        if (hit) {
+            this._setCanvasCursor('move');
+        } else {
+            this._setCanvasCursor('default');
+        }
+    }
+
+    _hitTestHandles(coords) {
+        if (!Array.isArray(this.selectionHandles) || !this.selectionHandles.length) {
+            return null;
+        }
+        for (let index = 0; index < this.selectionHandles.length; index += 1) {
+            const handle = this.selectionHandles[index];
+            if (!handle) {
+                continue;
+            }
+            const radius = handle.radius ?? this.handleRadius;
+            const dx = coords.x - handle.x;
+            const dy = coords.y - handle.y;
+            if (Math.hypot(dx, dy) <= radius) {
+                return handle;
+            }
+        }
+        return null;
+    }
+
+    _drawSelectionOverlay(ctx) {
+        if (!ctx || !this.selection) {
+            this.selectionHandles = [];
+            return;
+        }
+        const runtime = this._getSelectedRuntimeItem();
+        if (!runtime || !runtime.data) {
+            this.selection = null;
+            this.selectionHandles = [];
+            return;
+        }
+        const width = this._getItemWidth(runtime);
+        const height = this._getItemHeight(runtime);
+        if (!width || !height) {
+            this.selectionHandles = [];
+            return;
+        }
+        const transform = runtime.data.transform || {};
+        const halfWidth = width / 2;
+        const halfHeight = height / 2;
+        const corners = [
+            this._transformPoint(transform, -halfWidth, -halfHeight),
+            this._transformPoint(transform, halfWidth, -halfHeight),
+            this._transformPoint(transform, halfWidth, halfHeight),
+            this._transformPoint(transform, -halfWidth, halfHeight),
+        ];
+
+        ctx.save();
+        ctx.lineWidth = 1.5;
+        ctx.strokeStyle = 'rgba(13, 110, 253, 0.9)';
+        ctx.fillStyle = 'rgba(13, 110, 253, 0.85)';
+        ctx.setLineDash([6, 4]);
+        ctx.beginPath();
+        ctx.moveTo(corners[0].x, corners[0].y);
+        for (let i = 1; i < corners.length; i += 1) {
+            ctx.lineTo(corners[i].x, corners[i].y);
+        }
+        ctx.closePath();
+        ctx.stroke();
+        ctx.setLineDash([]);
+
+        const handles = this._computeSelectionHandles(transform, width, height);
+        this.selectionHandles = handles;
+        const rotationHandle = handles.find((handle) => handle.type === 'rotate');
+        if (rotationHandle?.anchor) {
+            ctx.beginPath();
+            ctx.moveTo(rotationHandle.anchor.x, rotationHandle.anchor.y);
+            ctx.lineTo(rotationHandle.x, rotationHandle.y);
+            ctx.stroke();
+        }
+
+        handles.forEach((handle) => {
+            ctx.beginPath();
+            if (handle.type === 'rotate') {
+                ctx.arc(handle.x, handle.y, handle.radius, 0, Math.PI * 2);
+                ctx.fill();
+                ctx.stroke();
+            } else {
+                const size = (handle.radius ?? this.handleRadius) * 1.4;
+                ctx.rect(handle.x - size / 2, handle.y - size / 2, size, size);
+                ctx.fill();
+                ctx.stroke();
+            }
+        });
+        ctx.restore();
+    }
+
+    _computeSelectionHandles(transform, width, height) {
+        const halfWidth = width / 2;
+        const halfHeight = height / 2;
+        const definitions = [
+            { key: 'nw', sx: -1, sy: -1, cursor: 'nwse-resize' },
+            { key: 'ne', sx: 1, sy: -1, cursor: 'nesw-resize' },
+            { key: 'se', sx: 1, sy: 1, cursor: 'nwse-resize' },
+            { key: 'sw', sx: -1, sy: 1, cursor: 'nesw-resize' },
+            { key: 'n', sx: 0, sy: -1, cursor: 'ns-resize' },
+            { key: 'e', sx: 1, sy: 0, cursor: 'ew-resize' },
+            { key: 's', sx: 0, sy: 1, cursor: 'ns-resize' },
+            { key: 'w', sx: -1, sy: 0, cursor: 'ew-resize' },
+        ];
+        const handles = definitions.map((def) => {
+            const point = this._transformPoint(transform, halfWidth * def.sx, halfHeight * def.sy);
+            return {
+                ...def,
+                type: 'scale',
+                x: point.x,
+                y: point.y,
+                radius: this.handleRadius,
+            };
+        });
+        const topCenter = this._transformPoint(transform, 0, -halfHeight);
+        const rotationPoint = this._transformPoint(transform, 0, -(halfHeight + this.rotationHandleOffset));
+        handles.push({
+            type: 'rotate',
+            cursor: 'grab',
+            x: rotationPoint.x,
+            y: rotationPoint.y,
+            radius: this.handleRadius + 2,
+            anchor: topCenter,
+        });
+        return handles;
+    }
+
+    _setSelection(layerId, item) {
+        if (!item || !item.data || !item.data.id) {
+            return;
+        }
+        const nextSelection = { layerId, itemId: item.data.id };
+        if (this.selection && this.selection.layerId === nextSelection.layerId && this.selection.itemId === nextSelection.itemId) {
+            return;
+        }
+        this.selection = nextSelection;
+        this.renderComposite();
+    }
+
+    _clearSelection(triggerRender = true) {
+        if (!this.selection) {
+            return;
+        }
+        this.selection = null;
+        this.selectionHandles = [];
+        if (triggerRender) {
+            this.renderComposite();
+        }
+    }
+
+    _getSelectedRuntimeItem() {
+        if (!this.selection) {
+            return null;
+        }
+        const surface = this.layerSurfaces.get(this.selection.layerId);
+        if (!surface) {
+            return null;
+        }
+        return surface.items.find((item) => item?.data?.id === this.selection.itemId) || null;
+    }
+
+    _setCanvasCursor(cursor) {
+        if (!this.canvas) {
+            return;
+        }
+        const value = cursor || 'default';
+        if (this.currentCursor === value) {
+            return;
+        }
+        this.canvas.style.cursor = value;
+        this.currentCursor = value;
+    }
+
+    _applyScaleFromPointer(coords, uniformScaling) {
+        if (!this.pointerState?.item || !this.pointerState.handle) {
+            return;
+        }
+        const { item, handle, baseWidth, baseHeight, scaleSignX = 1, scaleSignY = 1 } = this.pointerState;
+        const transform = item.data.transform || {};
+        const originX = transform.x ?? 0;
+        const originY = transform.y ?? 0;
+        const rotation = transform.rotation || 0;
+        const dx = coords.x - originX;
+        const dy = coords.y - originY;
+        const cos = Math.cos(-rotation);
+        const sin = Math.sin(-rotation);
+        const rotatedX = dx * cos - dy * sin;
+        const rotatedY = dx * sin + dy * cos;
+        const halfWidth = Math.max(1, baseWidth / 2);
+        const halfHeight = Math.max(1, baseHeight / 2);
+
+        if (handle.sx !== 0) {
+            const scaleMagnitudeX = Math.max(0.05, Math.abs(rotatedX) / halfWidth);
+            transform.scaleX = scaleMagnitudeX * scaleSignX;
+        }
+        if (handle.sy !== 0) {
+            const scaleMagnitudeY = Math.max(0.05, Math.abs(rotatedY) / halfHeight);
+            transform.scaleY = scaleMagnitudeY * scaleSignY;
+        }
+
+        if (uniformScaling && handle.sx !== 0 && handle.sy !== 0) {
+            const uniformScale = Math.max(
+                0.05,
+                Math.max(Math.abs(rotatedX) / halfWidth, Math.abs(rotatedY) / halfHeight)
+            );
+            transform.scaleX = uniformScale * scaleSignX;
+            transform.scaleY = uniformScale * scaleSignY;
+        }
+    }
+
+    _transformPoint(transform = {}, localX = 0, localY = 0) {
+        const scaleX = transform.scaleX ?? 1;
+        const scaleY = transform.scaleY ?? 1;
+        const rotation = transform.rotation || 0;
+        const cos = Math.cos(rotation);
+        const sin = Math.sin(rotation);
+        const scaledX = localX * scaleX;
+        const scaledY = localY * scaleY;
+        const x = (transform.x ?? 0) + (scaledX * cos - scaledY * sin);
+        const y = (transform.y ?? 0) + (scaledX * sin + scaledY * cos);
+        return { x, y };
+    }
+
+    _hitTest(layerId, x, y) {
+        const surface = this.layerSurfaces.get(layerId);
+        if (!surface) {
+            return null;
+        }
+        for (let i = surface.items.length - 1; i >= 0; i -= 1) {
+            const item = surface.items[i];
+            if (!item || !item.data || item.data.type === 'stroke' || item.data.role) {
+                continue;
+            }
+            if (this._pointInItem(x, y, item)) {
+                return item;
+            }
+        }
+        return null;
+    }
+
+    _pointInItem(x, y, item) {
+        const transform = item.data.transform || {};
+        const width = this._getItemWidth(item);
+        const height = this._getItemHeight(item);
+        const dx = x - (transform.x ?? 0);
+        const dy = y - (transform.y ?? 0);
+        const angle = -(transform.rotation || 0);
+        const cos = Math.cos(angle);
+        const sin = Math.sin(angle);
+        const localX = (dx * cos - dy * sin) / (transform.scaleX ?? 1);
+        const localY = (dx * sin + dy * cos) / (transform.scaleY ?? 1);
+        return localX >= -width / 2 && localX <= width / 2 && localY >= -height / 2 && localY <= height / 2;
+    }
+
+    _getItemWidth(item) {
+        if (item.data.type === 'text' && item.data.metrics) {
+            return item.data.metrics.width || (item.data.size || 48);
+        }
+        return item.data.width || item.image?.width || 0;
+    }
+
+    _getItemHeight(item) {
+        if (item.data.type === 'text' && item.data.metrics) {
+            return (item.data.metrics.actualBoundingBoxAscent + item.data.metrics.actualBoundingBoxDescent) || (item.data.size || 48);
+        }
+        return item.data.height || item.image?.height || 0;
+    }
+
+    _createStroke(tool, startPoint) {
+        return {
+            id: this._generateItemId('stroke'),
+            type: 'stroke',
+            tool,
+            color: this.brushSettings.color,
+            size: this.brushSettings.size,
+            opacity: this.brushSettings.opacity,
+            hardness: this.brushSettings.hardness,
+            points: [{ x: startPoint.x, y: startPoint.y }],
+        };
+    }
+
+    _maybeCreateMirroredStroke(stroke) {
+        if (!this.mirrorSettings?.enabled) {
+            return null;
+        }
+        const mirrored = JSON.parse(JSON.stringify(stroke));
+        mirrored.id = this._generateItemId('stroke-mirror');
+        mirrored.mirrorOf = stroke.id;
+        mirrored.points = stroke.points.map((point) => this._mirrorPoint(point.x, point.y));
+        if (this.mirrorSettings.mode === 'flip') {
+            mirrored.points.reverse();
+        }
+        return mirrored;
+    }
+
+    _maybeCreateMirroredItem(layer, item) {
+        if (!this.mirrorSettings?.enabled) {
+            return null;
+        }
+        const mirrored = JSON.parse(JSON.stringify(item));
+        mirrored.id = this._generateItemId(`${item.type}-mirror`);
+        mirrored.mirrorOf = item.id;
+        mirrored.transform = this._mirrorTransform(item.transform);
+        if (mirrored.type === 'sticker' || mirrored.type === 'image') {
+            mirrored.transform.scaleX *= -1;
+        }
+        return mirrored;
+    }
+
+    _maybeCreateMirroredText(layer, item) {
+        if (!this.mirrorSettings?.enabled) {
+            return null;
+        }
+        const mirrored = JSON.parse(JSON.stringify(item));
+        mirrored.id = this._generateItemId('text-mirror');
+        mirrored.mirrorOf = item.id;
+        mirrored.transform = this._mirrorTransform(item.transform);
+        mirrored.transform.scaleX *= -1;
+        if (this.mirrorSettings.mode === 'flip') {
+            mirrored.content = (mirrored.content || '').split('').reverse().join('');
+        }
+        return mirrored;
+    }
+
+    _mirrorTransform(transform = {}) {
+        const mirrored = { ...transform };
+        const axis = this.mirrorSettings?.axis || MIRROR_AXIS.x;
+        if (axis === MIRROR_AXIS.y) {
+            mirrored.y = this.canvas.height - (transform.y ?? 0);
+        } else {
+            const width = this.canvas.width;
+            mirrored.x = width - (transform.x ?? 0);
+        }
+        if (axis === MIRROR_AXIS.z) {
+            const width = this.canvas.width;
+            mirrored.x = width - (transform.x ?? 0);
+        }
+        mirrored.rotation = -(transform.rotation || 0);
+        mirrored.scaleY = transform.scaleY ?? 1;
+        mirrored.scaleX = transform.scaleX ?? 1;
+        return mirrored;
+    }
+
+    _mirrorPoint(x, y) {
+        const axis = this.mirrorSettings?.axis || MIRROR_AXIS.x;
+        if (axis === MIRROR_AXIS.y) {
+            return { x, y: this.canvas.height - y };
+        }
+        const width = this.canvas.width;
+        return { x: width - x, y };
+    }
+
+    _updateMirrorTransform(source, target, invertRotation = false) {
+        const mirrored = this._mirrorTransform(source);
+        target.x = mirrored.x;
+        target.y = mirrored.y;
+        target.scaleX = mirrored.scaleX * (target.scaleX < 0 ? -1 : 1);
+        target.scaleY = mirrored.scaleY;
+        target.rotation = invertRotation ? -source.rotation : mirrored.rotation;
+    }
+
+    _computeRotationOffset(transform, x, y) {
+        const dx = x - (transform.x ?? 0);
+        const dy = y - (transform.y ?? 0);
+        const startAngle = Math.atan2(dy, dx);
+        return startAngle - (transform.rotation || 0);
+    }
+
+    _findMirrorItem(layerId, item) {
+        const surface = this.layerSurfaces.get(layerId);
+        if (!surface) {
+            return null;
+        }
+        return surface.items.find((candidate) => candidate?.data?.mirrorOf === item.data.id || candidate?.data?.id === item.data.mirrorOf) || null;
+    }
+
+    _ensureCanvasSize(width, height) {
+        if (!this.canvas) {
+            return;
+        }
+        if (this.canvas.width === width && this.canvas.height === height) {
+            return;
+        }
+        this.canvas.width = width;
+        this.canvas.height = height;
+        this.layerSurfaces.forEach((surface) => {
+            surface.canvas.width = width;
+            surface.canvas.height = height;
+        });
+        this.compositeSurfaces.forEach((surface) => {
+            surface.canvas.width = width;
+            surface.canvas.height = height;
+        });
+    }
+
+    _getCanvasCoordinates(event) {
+        const rect = this.canvas.getBoundingClientRect();
+        const x = (event.clientX - rect.left) * (this.canvas.width / rect.width);
+        const y = (event.clientY - rect.top) * (this.canvas.height / rect.height);
+        return { x, y };
+    }
+
+    _generateItemId(prefix) {
+        if (typeof globalThis.crypto?.randomUUID === 'function') {
+            return `${prefix}-${globalThis.crypto.randomUUID()}`;
+        }
+        return `${prefix}-${Date.now().toString(36)}-${Math.random().toString(36).slice(2, 8)}`;
+    }
+
+    _loadImage(src) {
+        if (!src) {
+            return Promise.reject(new Error('Missing image source'));
+        }
+        if (this.imageCache.has(src)) {
+            return this.imageCache.get(src);
+        }
+        const promise = new Promise((resolve, reject) => {
+            const img = new Image();
+            if (!src.startsWith('data:')) {
+                img.crossOrigin = 'anonymous';
+            }
+            img.onload = () => resolve(img);
+            img.onerror = (error) => reject(error);
+            img.src = src;
+        });
+        this.imageCache.set(src, promise);
+        return promise;
+    }
+
+    async _onBaseTextureChange(event) {
+        const detail = event?.detail;
+        if (!detail) {
+            return;
+        }
+        if (detail.type === 'decals' || detail.type === 'sponsors') {
+            await this._applyBaseTexture(detail.type, detail.url);
+            this.renderComposite();
+        }
+    }
+
+    async _onBaseLayersReady(event) {
+        await this._loadTemplateFromSelection();
+    }
+}
+
diff --git a/src/materialManager.js b/src/materialManager.js
index b69096001176b0d85367f0017fd56ec4380d1ebc..4edcf48e8f2a7c0e8d5762611337f6e7b053f702 100644
--- a/src/materialManager.js
+++ b/src/materialManager.js
@@ -1,37 +1,54 @@
 import * as THREE from 'three';
 
 export class MaterialManager {
     constructor(state) {
         this.state = state;
         this.modelLoader = null;
         // Track resources for memory monitoring
         this.resourceTracker = {
             textures: new Set(),
             materials: new Set(),
             meshes: new Set()
         };
+        this.overlayMeshes = new Map();
+        this.editorOverlayMap = {
+            decals: {
+                materialName: 'DecalMaterial',
+                presetKeys: ['customDecal', 'glossy'],
+                fallback: 'glossy'
+            },
+            sponsors: {
+                materialName: 'SponsorMaterial',
+                presetKeys: ['customSponsor', 'matte'],
+                fallback: 'matte'
+            }
+        };
+        this._onEditorCanvasUpdated = this._onEditorCanvasUpdated.bind(this);
+        if (typeof document !== 'undefined' && document.addEventListener) {
+            document.addEventListener('editor:canvasUpdated', this._onEditorCanvasUpdated);
+        }
     }
 
     setModelLoader(modelLoader) {
         this.modelLoader = modelLoader;
     }
 
     applyMaterialPreset(material, preset) {
         if (typeof material === 'string') {
             material = this.getMaterialFromName(material);
         }
 
         if (!material) {
             return false;
         }
 
         if (Array.isArray(material)) {
             let result = false;
             material.forEach((mat) => {
                 result = this.applyMaterialPreset(mat, preset) || result;
             });
             return result;
         }
 
         if (material && material.id) {
             // Early return if preset is the same
@@ -111,82 +128,87 @@ export class MaterialManager {
             img.onload = () => resolve(img);
             img.onerror = () => reject(`Failed to load image from ${src}`);
         });
     }
 
     createTextureFromCanvas(canvas) {
         const texture = new THREE.Texture(canvas);
         texture.flipY = false;
         texture.colorSpace = THREE.SRGBColorSpace;
         texture.anisotropy = 8;
         texture.needsUpdate = true;
         
         // Track texture for cleanup
         this.resourceTracker.textures.add(texture);
         this.state.trackResource('textures');
         
         this.state.bodyTextures.push(texture);
         return texture;
     }
 
     applyTextureToModel(texture, materialName, preset) {
         const { model, scene } = this.state;
         if (!model || !scene) {
             return null;
         }
+        const existingMesh = this.overlayMeshes.get(materialName);
+        if (existingMesh) {
+            this.cleanupMesh(existingMesh);
+        }
         let mesh = null;
         model.traverse((node) => {
             if (node.isMesh && node.material.name === 'EXT_Carpaint_Inst') {
                 const material = new THREE.MeshPhysicalMaterial({
                     name: materialName,
                     map: texture,
                     transparent: true,
                     opacity: 1,
                     envMap: scene.environment,
                     depthWrite: false,
                     depthTest: true,
                 });
                 this.applyMaterialPreset(material, preset);
                 
                 // Track material for cleanup
                 this.resourceTracker.materials.add(material);
                 this.state.trackResource('materials');
                 
                 const overlayMesh = new THREE.Mesh(node.geometry, material);
                 overlayMesh.position.copy(node.position);
                 overlayMesh.rotation.copy(node.rotation);
                 overlayMesh.scale.copy(node.scale).multiplyScalar(1.0001);
                 
                 // Track mesh for cleanup
                 this.resourceTracker.meshes.add(overlayMesh);
                 this.state.trackResource('meshes');
                 
                 scene.add(overlayMesh);
                 mesh = overlayMesh;
             }
         });
         if (mesh) {
+            this.overlayMeshes.set(materialName, mesh);
             this.state.addExtraMesh(mesh);
         }
         return mesh;
     }
 
     async drawImageOverlay(file, materialName, preset) {
         if (!file) {
             return null;
         }
         try {
             const image = await this.loadImage(file);
             const canvas = setupCanvas(image);
             const context = canvas.getContext('2d');
             context.drawImage(image, 0, 0);
             const texture = this.createTextureFromCanvas(canvas);
             return this.applyTextureToModel(texture, materialName, preset);
         } catch (error) {
             console.error(error);
             return null;
         }
     }
 
     async convertImageToRGBChannels(imagePath) {
         const canvas = document.createElement('canvas');
         const ctx = canvas.getContext('2d');
@@ -253,110 +275,126 @@ export class MaterialManager {
             images = await this.convertImageToRGBChannels(`models/${modelPath}/skins/custom/${liveryPath}/EXT_Skin_Sponsors.png`);
         } else {
             images = await this.convertImageToRGBChannels(`models/${modelPath}/skins/custom/${liveryPath}/EXT_Skin_Custom.png`);
         }
 
         for (let i = 0; i < images.length; i++) {
             await this.drawImageOverlay(images[i], `baseLivery${i + 1}`, paintMaterials.customDecal || paintMaterials.glossy);
         }
 
         if (liveryData.hasDecals) {
             await this.drawImageOverlay(
                 `models/${modelPath}/skins/custom/${liveryPath}/EXT_Skin_Decals.png`,
                 'fanatec_overlay',
                 paintMaterials.glossy
             );
         }
         this.applyBodyColours();
     }
 
     cleanupMesh(mesh) {
         const { scene } = this.state;
         if (!mesh || !scene) {
             return;
         }
         scene.remove(mesh);
-        
+
+        if (Array.isArray(this.state.extraMeshes) && this.state.extraMeshes.length) {
+            this.state.extraMeshes = this.state.extraMeshes.filter((tracked) => tracked !== mesh);
+        }
+
+        if (this.overlayMeshes && this.overlayMeshes.size) {
+            for (const [name, tracked] of this.overlayMeshes.entries()) {
+                if (tracked === mesh) {
+                    this.overlayMeshes.delete(name);
+                }
+            }
+        }
+
         // Proper cleanup of mesh resources
         if (mesh.material) {
             if (mesh.material.map) {
                 mesh.material.map.dispose();
                 this.resourceTracker.textures.delete(mesh.material.map);
                 this.state.untrackResource('textures');
             }
             mesh.material.dispose();
             this.resourceTracker.materials.delete(mesh.material);
             this.state.untrackResource('materials');
         }
         if (mesh.geometry) {
             mesh.geometry.dispose();
             this.state.untrackResource('geometries');
         }
         
         // Remove from tracking
         this.resourceTracker.meshes.delete(mesh);
         this.state.untrackResource('meshes');
     }
 
     cleanupPreviousMeshes() {
+        this.clearEditorOverlays();
         // Cleanup extra meshes
         this.state.extraMeshes.forEach((mesh) => this.cleanupMesh(mesh));
         this.state.resetExtraMeshes();
         
         // Cleanup body textures
         this.state.bodyTextures.forEach((texture) => {
             if (texture) {
                 texture.dispose();
                 this.resourceTracker.textures.delete(texture);
                 this.state.untrackResource('textures');
             }
         });
         this.state.bodyTextures = [];
 
         const { scene } = this.state;
         if (!scene) {
             return;
         }
         
         // Cleanup sponsor and decal materials
         scene.traverse((child) => {
             if (
                 child.isMesh &&
                 child.material &&
                 (child.material.name === 'SponsorMaterial' || child.material.name === 'DecalMaterial')
             ) {
                 if (child.material.map) {
                     child.material.map.dispose();
                     this.resourceTracker.textures.delete(child.material.map);
                     this.state.untrackResource('textures');
                 }
                 child.material.dispose();
                 this.resourceTracker.materials.delete(child.material);
                 this.state.untrackResource('materials');
                 scene.remove(child);
             }
         });
+        if (this.overlayMeshes) {
+            this.overlayMeshes.clear();
+        }
     }
 
     // Add comprehensive cleanup method for all resources
     cleanupAllResources() {
         // Cleanup previous meshes
         this.cleanupPreviousMeshes();
         
         // Cleanup any remaining tracked resources
         this.resourceTracker.textures.forEach(texture => {
             try {
                 texture.dispose();
             } catch (e) {
                 // Ignore errors during disposal
             }
         });
         this.resourceTracker.textures.clear();
         
         this.resourceTracker.materials.forEach(material => {
             try {
                 material.dispose();
             } catch (e) {
                 // Ignore errors during disposal
             }
         });
         this.resourceTracker.materials.clear();
@@ -395,66 +433,182 @@ export class MaterialManager {
         const { scene } = this.state;
         const canvas = document.getElementById('hiddenCanvas');
         if (canvas) {
             const ctx = canvas.getContext('2d');
             ctx.clearRect(0, 0, canvas.width, canvas.height);
         }
 
         if (scene) {
             scene.traverse((node) => {
                 if (node.isMesh && node.material.name === 'EXT_Carpaint_Inst') {
                     this.applyMaterialPreset(node.material, paintMaterials.customDecal || paintMaterials.glossy);
                     node.material.needsUpdate = true;
                 }
             });
         }
 
         await this.drawImageOverlay(this.state.decalsFile, 'DecalMaterial', paintMaterials.customDecal || paintMaterials.glossy);
         await this.drawImageOverlay(
             this.state.sponsorsFile,
             'SponsorMaterial',
             paintMaterials.customSponsor || paintMaterials.matte
         );
         this.applyBodyColours();
         window.viewerReady = true;
         window.dispatchEvent(new Event('viewer-ready'));
+        document.dispatchEvent(new CustomEvent('editor:baseLayersReady', {
+            detail: { modelPath: currentModelPath, liveryId: activeLivery }
+        }));
     }
 
     setDecalsFile(url) {
         this.state.setDecalsFile(url);
+        document.dispatchEvent(new CustomEvent('editor:baseTextureChanged', {
+            detail: { type: 'decals', url }
+        }));
     }
 
     setSponsorsFile(url) {
         this.state.setSponsorsFile(url);
+        document.dispatchEvent(new CustomEvent('editor:baseTextureChanged', {
+            detail: { type: 'sponsors', url }
+        }));
     }
 
     resetCustomLivery() {
         this.cleanupPreviousMeshes();
         this.state.setDecalsFile(null);
         this.state.setSponsorsFile(null);
         paintMaterials.customDecal = undefined;
         paintMaterials.customSponsor = undefined;
+        document.dispatchEvent(new CustomEvent('editor:baseTextureChanged', {
+            detail: { type: 'decals', url: null }
+        }));
+        document.dispatchEvent(new CustomEvent('editor:baseTextureChanged', {
+            detail: { type: 'sponsors', url: null }
+        }));
+    }
+
+    _onEditorCanvasUpdated(event) {
+        const detail = event?.detail;
+        if (detail?.origin === 'liveryEditor' && detail?.applied) {
+            return;
+        }
+        if (detail?.overlays && typeof detail.overlays === 'object') {
+            Object.entries(detail.overlays).forEach(([type, canvas]) => {
+                this.updateEditorOverlay(type, canvas);
+            });
+            return;
+        }
+
+        if (detail?.type && detail.canvas) {
+            this.updateEditorOverlay(detail.type, detail.canvas);
+            return;
+        }
+
+        const canvas = detail?.canvas || document.getElementById('hiddenCanvas');
+        if (!canvas) {
+            return;
+        }
+
+        this.updateEditorOverlay('decals', canvas);
+        if (this.overlayMeshes.has('SponsorMaterial')) {
+            this.updateEditorOverlay('sponsors', canvas);
+        }
+    }
+
+    _applyCanvasToMaterial(canvas, materialName, preset) {
+        if (!canvas) {
+            return null;
+        }
+
+        const mesh = this.overlayMeshes.get(materialName);
+        if (mesh && mesh.material && mesh.material.map) {
+            mesh.material.map.image = canvas;
+            mesh.material.map.needsUpdate = true;
+            this.applyMaterialPreset(mesh.material, preset);
+            mesh.material.needsUpdate = true;
+            return mesh;
+        }
+
+        if (!this.state.model || !this.state.scene) {
+            return null;
+        }
+
+        const texture = this.createTextureFromCanvas(canvas);
+        return this.applyTextureToModel(texture, materialName, preset);
+    }
+
+    updateEditorOverlay(type, canvas) {
+        const config = this.editorOverlayMap?.[type];
+        if (!config) {
+            return null;
+        }
+
+        if (!canvas) {
+            this._removeOverlayByMaterial(config.materialName);
+            return null;
+        }
+
+        const preset = this._resolveOverlayPreset(config.presetKeys, config.fallback);
+        return this._applyCanvasToMaterial(canvas, config.materialName, preset);
+    }
+
+    clearEditorOverlays() {
+        Object.keys(this.editorOverlayMap || {}).forEach((type) => {
+            const config = this.editorOverlayMap[type];
+            this._removeOverlayByMaterial(config.materialName);
+        });
+    }
+
+    _resolveOverlayPreset(presetKeys = [], fallbackKey = null) {
+        if (Array.isArray(presetKeys)) {
+            for (const key of presetKeys) {
+                if (paintMaterials?.[key]) {
+                    return paintMaterials[key];
+                }
+            }
+        }
+        if (fallbackKey && paintMaterials?.[fallbackKey]) {
+            return paintMaterials[fallbackKey];
+        }
+        if (paintMaterials?.glossy) {
+            return paintMaterials.glossy;
+        }
+        const firstKey = Object.keys(paintMaterials || {})[0];
+        return firstKey ? paintMaterials[firstKey] : null;
+    }
+
+    _removeOverlayByMaterial(materialName) {
+        if (!materialName) {
+            return;
+        }
+        const mesh = this.overlayMeshes.get(materialName);
+        if (mesh) {
+            this.cleanupMesh(mesh);
+            this.overlayMeshes.delete(materialName);
+        }
     }
 
     applyCarJsonData(data) {
         const isCarbon = data.skinTemplateKey === 98 || data.skinTemplateKey === 99;
         if (data.skinColor1Id !== undefined && !isCarbon) {
             this.state.bodyColours[0] = coloridToHex(data.skinColor1Id);
         }
         if (data.skinColor2Id !== undefined && !isCarbon) {
             this.state.bodyColours[1] = coloridToHex(data.skinColor2Id);
         }
         if (data.skinColor3Id !== undefined && !isCarbon) {
             this.state.bodyColours[2] = coloridToHex(data.skinColor3Id);
         }
         if (isCarbon) {
             const carbonHex = coloridToHex(1);
             this.state.bodyColours[0] = carbonHex;
             this.state.bodyColours[1] = carbonHex;
             this.state.bodyColours[2] = carbonHex;
         }
         if (data.rimColor1Id !== undefined) {
             this.state.bodyColours[3] = coloridToHex(data.rimColor1Id);
         }
 
         if (data.skinMaterialType1 !== undefined && materialIdToName[data.skinMaterialType1]) {
             this.state.bodyMaterials[0] = materialIdToName[data.skinMaterialType1];
diff --git a/src/state.js b/src/state.js
index 7d3f3afb07e985e7c4de4647b46138c22a34f076..1254e0602c72360b22d2bdae5c5bebef681e4bb3 100644
--- a/src/state.js
+++ b/src/state.js
@@ -10,50 +10,54 @@ export class AppState {
         this.prevModelPath = null;
         this.currentModelPath = null;
         this.currentLivery = null;
         this.envMap = null;
         this.extraMeshes = [];
         this.wheelMeshes = [];
         this.bodyColours = ['#ff0000', '#00ff00', '#0000ff', '#fafafa'];
         this.bodyMaterials = ['glossy', 'glossy', 'glossy', 'glossy'];
         this.bodyTextures = [];
         this.lodLevel = 3;
         this.currentSkybox = typeof cubemaps !== 'undefined' ? cubemaps[0] : null;
         this.skyboxEnabled = false;
         this.decalsFile = null;
         this.sponsorsFile = null;
         this.firstRun = true;
         // Resource tracking for memory monitoring
         this.resourceStats = {
             textures: 0,
             geometries: 0,
             materials: 0,
             meshes: 0,
             lights: 0,
             other: 0
         };
         this.resourceCleanupCallbacks = [];
+
+        this.editorListeners = new Set();
+
+        this.resetEditorState();
     }
 
     setScene(scene) {
         this.scene = scene;
     }
 
     setCamera(camera) {
         this.camera = camera;
     }
 
     setRenderer(renderer) {
         this.renderer = renderer;
     }
 
     setComposer(composer) {
         this.composer = composer;
     }
 
     setGtaoPass(pass) {
         this.gtaoPass = pass;
     }
 
     setSmaaPass(pass) {
         this.smaaPass = pass;
     }
@@ -121,37 +125,407 @@ export class AppState {
         }
     }
 
     untrackResource(type, count = 1) {
         if (this.resourceStats.hasOwnProperty(type)) {
             this.resourceStats[type] = Math.max(0, this.resourceStats[type] - count);
         } else {
             this.resourceStats.other = Math.max(0, this.resourceStats.other - count);
         }
     }
 
     addCleanupCallback(callback) {
         this.resourceCleanupCallbacks.push(callback);
     }
 
     cleanupResources() {
         // Execute all cleanup callbacks
         this.resourceCleanupCallbacks.forEach(callback => {
             try {
                 callback();
             } catch (error) {
                 console.warn('Error in resource cleanup callback:', error);
             }
         });
         this.resourceCleanupCallbacks = [];
-        
+
         // Reset resource stats
         this.resourceStats = {
             textures: 0,
             geometries: 0,
             materials: 0,
             meshes: 0,
             lights: 0,
             other: 0
         };
+
+        this.resetEditorState();
+    }
+
+    // Editor state helpers
+    resetEditorState() {
+        this.layers = [];
+        this.baseLayers = { decals: null, sponsors: null };
+        this.activeLayerId = null;
+        this.activeTool = null;
+        this.symmetrySettings = {
+            enabled: false,
+            axis: 'x',
+            mode: 'mirror'
+        };
+        this.undoStack = [];
+        this.redoStack = [];
+        this.maxUndoSteps = 50;
+        this.dirtyLayers = new Set();
+        this.globalTextureDirty = false;
+
+        this._emitEditorEvent('reset');
+    }
+
+    setActiveLayer(layerId) {
+        if (layerId === null || this.getLayerById(layerId)) {
+            this.activeLayerId = layerId;
+            this._emitEditorEvent('activeLayerChanged', { layerId });
+        }
+    }
+
+    setActiveTool(tool) {
+        this.activeTool = tool;
+        this._emitEditorEvent('activeToolChanged', { tool });
+    }
+
+    setSymmetrySettings(settings = {}) {
+        this.symmetrySettings = {
+            ...this.symmetrySettings,
+            ...settings
+        };
+        this._emitEditorEvent('symmetryChanged', { settings: { ...this.symmetrySettings } });
+    }
+
+    getLayerById(layerId) {
+        return this.layers.find(layer => layer.id === layerId) || null;
+    }
+
+    registerBaseLayer(type, layerId) {
+        if (!type || !layerId) {
+            return;
+        }
+        const normalized = type.toLowerCase();
+        if (normalized === 'decals' || normalized === 'decalsbase') {
+            this.baseLayers.decals = layerId;
+        } else if (normalized === 'sponsors' || normalized === 'sponsorsbase') {
+            this.baseLayers.sponsors = layerId;
+        }
+    }
+
+    insertLayer(layerData, index = this.layers.length) {
+        if (!layerData) {
+            return null;
+        }
+
+        const layer = this._normalizeLayer(layerData, { preserveId: true });
+
+        if (index < 0 || index > this.layers.length) {
+            index = this.layers.length;
+        }
+
+        this.layers.splice(index, 0, layer);
+
+        const baseType = (layer.baseType || layer.type || '').toLowerCase();
+        if ((layer.isBase || !this.baseLayers.decals) && (baseType === 'decals' || baseType === 'decalsbase')) {
+            this.registerBaseLayer('decals', layer.id);
+        } else if ((layer.isBase || !this.baseLayers.sponsors) && (baseType === 'sponsors' || baseType === 'sponsorsbase')) {
+            this.registerBaseLayer('sponsors', layer.id);
+        }
+
+        this.markLayerDirty(layer.id);
+        this._emitEditorEvent('layerInserted', { layer: { ...layer }, index });
+        return layer;
+    }
+
+    deleteLayer(layerId) {
+        const layer = this.getLayerById(layerId);
+        if (!layer) {
+            return false;
+        }
+
+        const baseType = (layer.baseType || layer.type || '').toLowerCase();
+        const isProtectedBase =
+            layer.locked ||
+            layer.isBase ||
+            this.baseLayers.decals === layerId ||
+            this.baseLayers.sponsors === layerId ||
+            baseType === 'decals' ||
+            baseType === 'decalsbase' ||
+            baseType === 'sponsors' ||
+            baseType === 'sponsorsbase';
+
+        if (isProtectedBase) {
+            console.warn('Attempted to delete a protected layer:', layerId);
+            return false;
+        }
+
+        this.layers = this.layers.filter(existing => existing.id !== layerId);
+        if (this.activeLayerId === layerId) {
+            this.activeLayerId = null;
+        }
+
+        this.markLayerDirty(layerId);
+        this._emitEditorEvent('layerDeleted', { layerId });
+        return true;
+    }
+
+    reorderLayer(layerId, newIndex) {
+        const currentIndex = this.layers.findIndex(layer => layer.id === layerId);
+        if (currentIndex === -1) {
+            return false;
+        }
+
+        if (newIndex < 0) {
+            newIndex = 0;
+        } else if (newIndex >= this.layers.length) {
+            newIndex = this.layers.length - 1;
+        }
+
+        const [layer] = this.layers.splice(currentIndex, 1);
+        this.layers.splice(newIndex, 0, layer);
+
+        this.markLayerDirty(layerId);
+        this._emitEditorEvent('layerReordered', { layerId, index: newIndex });
+        return true;
+    }
+
+    mergeLayers(targetLayerId, sourceLayerId, mergeCallback) {
+        const targetLayer = this.getLayerById(targetLayerId);
+        const sourceLayer = this.getLayerById(sourceLayerId);
+
+        if (!targetLayer || !sourceLayer) {
+            return false;
+        }
+
+        if (targetLayer.locked || sourceLayer.locked) {
+            console.warn('Attempted to merge locked layers.');
+            return false;
+        }
+
+        if (sourceLayer.isBase ||
+            this.baseLayers.decals === sourceLayerId ||
+            this.baseLayers.sponsors === sourceLayerId) {
+            console.warn('Attempted to merge from a protected base layer.');
+            return false;
+        }
+
+        const sourceBaseType = (sourceLayer.baseType || sourceLayer.type || '').toLowerCase();
+        if (sourceBaseType === 'decals' || sourceBaseType === 'decalsbase' ||
+            sourceBaseType === 'sponsors' || sourceBaseType === 'sponsorsbase') {
+            console.warn('Attempted to merge from a protected base layer.');
+            return false;
+        }
+
+        if (typeof mergeCallback === 'function') {
+            mergeCallback(targetLayer, sourceLayer);
+        }
+
+        this.deleteLayer(sourceLayerId);
+        this.markLayerDirty(targetLayerId);
+        this._emitEditorEvent('layersMerged', { targetLayerId, sourceLayerId });
+        return true;
+    }
+
+    markLayerDirty(layerId = null) {
+        if (layerId) {
+            this.dirtyLayers.add(layerId);
+        }
+        this.globalTextureDirty = true;
+        this._emitEditorEvent('layerDirty', { layerId });
+    }
+
+    consumeDirtyLayers() {
+        const dirty = Array.from(this.dirtyLayers);
+        this.dirtyLayers.clear();
+        this.globalTextureDirty = false;
+        return dirty;
+    }
+
+    recordUndoState(snapshot = this.captureEditorState()) {
+        if (!snapshot) {
+            return;
+        }
+        const safeSnapshot = this._cloneState(snapshot);
+        if (safeSnapshot) {
+            this.undoStack.push(safeSnapshot);
+            if (this.undoStack.length > this.maxUndoSteps) {
+                this.undoStack.shift();
+            }
+            this.redoStack = [];
+        }
+    }
+
+    undo() {
+        if (!this.undoStack.length) {
+            return null;
+        }
+        const current = this.captureEditorState();
+        const snapshot = this.undoStack.pop();
+        if (current) {
+            const currentClone = this._cloneState(current);
+            if (currentClone) {
+                this.redoStack.push(currentClone);
+            }
+        }
+        const restored = this._cloneState(snapshot);
+        if (restored) {
+            this.applyEditorState(restored);
+        }
+        return restored;
+    }
+
+    redo() {
+        if (!this.redoStack.length) {
+            return null;
+        }
+        const current = this.captureEditorState();
+        const snapshot = this.redoStack.pop();
+        if (current) {
+            const currentClone = this._cloneState(current);
+            if (currentClone) {
+                this.undoStack.push(currentClone);
+            }
+        }
+        const restored = this._cloneState(snapshot);
+        if (restored) {
+            this.applyEditorState(restored);
+        }
+        return restored;
+    }
+
+    captureEditorState() {
+        return {
+            layers: this.layers.map(layer => this._cloneLayer(layer)),
+            baseLayers: { ...this.baseLayers },
+            activeLayerId: this.activeLayerId,
+            activeTool: this.activeTool,
+            symmetrySettings: { ...this.symmetrySettings }
+        };
+    }
+
+    applyEditorState(state) {
+        if (!state) {
+            return;
+        }
+        this.layers = state.layers ? state.layers.map(layer => this._normalizeLayer(layer, { preserveId: true })) : [];
+        this.baseLayers = state.baseLayers ? { ...state.baseLayers } : { decals: null, sponsors: null };
+        this.activeLayerId = state.activeLayerId || null;
+        this.activeTool = state.activeTool || null;
+        this.symmetrySettings = state.symmetrySettings ? { ...state.symmetrySettings } : { enabled: false, axis: 'x', mode: 'mirror' };
+        this.markLayerDirty();
+        this._emitEditorEvent('stateApplied', { state: this.captureEditorState() });
+    }
+
+    _generateLayerId() {
+        return `layer-${Date.now().toString(36)}-${Math.random().toString(36).slice(2, 8)}`;
+    }
+
+    _cloneState(state) {
+        if (state == null) {
+            return null;
+        }
+        if (typeof globalThis.structuredClone === 'function') {
+            try {
+                return globalThis.structuredClone(state);
+            } catch (error) {
+                console.warn('structuredClone failed for editor state, falling back to JSON clone.', error);
+            }
+        }
+        try {
+            return JSON.parse(JSON.stringify(state));
+        } catch (error) {
+            console.warn('Failed to clone editor state snapshot.', error);
+            return null;
+        }
+    }
+
+    _cloneLayer(layer) {
+        if (!layer) {
+            return null;
+        }
+        return {
+            id: layer.id,
+            name: layer.name,
+            type: layer.type,
+            locked: Boolean(layer.locked),
+            visible: layer.visible !== false,
+            isBase: Boolean(layer.isBase),
+            baseType: layer.baseType || null,
+            metadata: this._cloneLayerMetadata(layer.metadata)
+        };
+    }
+
+    _normalizeLayer(layerData = {}, { preserveId = true } = {}) {
+        const id = preserveId && layerData.id ? layerData.id : (layerData.id || this._generateLayerId());
+        const normalized = {
+            id,
+            name: layerData.name || 'Layer',
+            type: layerData.type || 'paint',
+            locked: Boolean(layerData.locked),
+            visible: layerData.visible !== false,
+            isBase: Boolean(layerData.isBase),
+            baseType: layerData.baseType || null,
+            metadata: this._cloneLayerMetadata(layerData.metadata)
+        };
+        return normalized;
+    }
+
+    _cloneLayerMetadata(metadata) {
+        const source = metadata && typeof metadata === 'object' ? metadata : {};
+        const cloned = { ...source };
+        cloned.items = Array.isArray(source.items)
+            ? source.items.map((item) => this._cloneLayerItem(item))
+            : [];
+        return cloned;
+    }
+
+    _cloneLayerItem(item) {
+        if (item == null) {
+            return item;
+        }
+        if (typeof globalThis.structuredClone === 'function') {
+            try {
+                return globalThis.structuredClone(item);
+            } catch (error) {
+                console.warn('structuredClone failed for layer item, falling back to JSON clone.', error);
+            }
+        }
+        try {
+            return JSON.parse(JSON.stringify(item));
+        } catch (error) {
+            console.warn('Failed to clone editor layer item.', error);
+            return { ...item };
+        }
+    }
+
+    addEditorListener(listener) {
+        if (typeof listener === 'function') {
+            this.editorListeners.add(listener);
+        }
+    }
+
+    removeEditorListener(listener) {
+        if (listener && this.editorListeners.has(listener)) {
+            this.editorListeners.delete(listener);
+        }
+    }
+
+    _emitEditorEvent(type, detail = {}) {
+        if (!this.editorListeners.size) {
+            return;
+        }
+        const payload = { type, detail, state: this };
+        this.editorListeners.forEach((listener) => {
+            try {
+                listener(payload);
+            } catch (error) {
+                console.warn('Editor listener error:', error);
+            }
+        });
     }
 }
diff --git a/src/uiController.js b/src/uiController.js
index ad44585016c51af9e9e5af2a2397b0815645fe3f..aa178d36474e2e7d857410e3007021da7ecf98db 100644
--- a/src/uiController.js
+++ b/src/uiController.js
@@ -1,91 +1,113 @@
 export class UIController {
-    constructor(state, modelLoader, materialManager, environmentManager) {
+    constructor(state, modelLoader, materialManager, environmentManager, liveryEditor) {
         this.state = state;
         this.modelLoader = modelLoader;
         this.materialManager = materialManager;
         this.environmentManager = environmentManager;
+        this.liveryEditor = liveryEditor;
         this.fileActions = {
             'decals.png': (file) => {
                 // Cleanup previous decals URL if exists
                 if (this.state.decalsFile) {
                     URL.revokeObjectURL(this.state.decalsFile);
                 }
                 this.materialManager.setDecalsFile(URL.createObjectURL(file));
             },
             'sponsors.png': (file) => {
                 // Cleanup previous sponsors URL if exists
                 if (this.state.sponsorsFile) {
                     URL.revokeObjectURL(this.state.sponsorsFile);
                 }
                 this.materialManager.setSponsorsFile(URL.createObjectURL(file));
             },
             'decals.json': (content) => {
                 paintMaterials.customDecal = content;
             },
             'sponsors.json': (content) => {
                 paintMaterials.customSponsor = content;
             },
             'car.json': (content) => {
                 const { bodyColours, bodyMaterials } = this.materialManager.applyCarJsonData(content);
                 this.updateColourPickers(bodyColours);
                 this.updateMaterialSelectors(bodyMaterials);
             },
         };
     }
 
     async initialize() {
         this.cacheDomElements();
+        this.ensureBrushSettings();
         this.populateSelectors();
         this.loadSettingsFromCookies();
         await this.applyUrlParameters();
+        this.syncEditorPanelControls();
+        this.renderLayerList();
         this.registerEventListeners();
         this.registerDragAndDrop();
     }
 
     cacheDomElements() {
         this.modelSelector = document.getElementById('modelSelector');
         this.liverySelector = document.getElementById('liverySelector');
         this.cubemapSelector = document.getElementById('cubemapSelector');
         this.lodSelector = document.getElementById('lodSelector');
         this.skyboxToggle = document.getElementById('skybox-toggle');
         this.postProcessingToggle = document.getElementById('post-processing-toggle');
         this.layerColourPickers = [
             document.getElementById('layer1Color'),
             document.getElementById('layer2Color'),
             document.getElementById('layer3Color'),
             document.getElementById('rimColor'),
         ];
         this.layerMaterialSelectors = [
             document.getElementById('layer1Material'),
             document.getElementById('layer2Material'),
             document.getElementById('layer3Material'),
             document.getElementById('rimMaterial'),
         ];
         this.unloadLiveryButton = document.getElementById('unloadCustomLivery');
         this.fileInput = document.getElementById('fileInput');
         this.multiFileUpload = document.getElementById('multiFileUpload');
+        this.editorPanel = document.getElementById('editorPanel');
+        this.editorPanelToggle = document.getElementById('editorPanelToggle');
+        this.editorPanelClose = document.getElementById('editorPanelClose');
+        this.layerList = document.getElementById('layerList');
+        this.createLayerButton = document.getElementById('createLayerButton');
+        this.mergeLayerButton = document.getElementById('mergeLayerButton');
+        this.toolSelect = document.getElementById('toolSelect');
+        this.brushSizeRange = document.getElementById('brushSizeRange');
+        this.brushOpacityRange = document.getElementById('brushOpacityRange');
+        this.brushHardnessRange = document.getElementById('brushHardnessRange');
+        this.mirrorToggleInput = document.getElementById('mirrorToggle');
+        this.mirrorAxisSelect = document.getElementById('mirrorAxisSelect');
+        this.mirrorModeSelect = document.getElementById('mirrorModeSelect');
+        this.stickerUploadInput = document.getElementById('stickerUploadInput');
+        this.textEntryForm = document.getElementById('textEntryForm');
+        this.textEntryInput = document.getElementById('textEntryInput');
+        this.exportLiveryButton = document.getElementById('exportLiveryButton');
+        this.uvBackgroundToggle = document.getElementById('uvBackgroundToggle');
     }
 
     setModelSelection(value) {
         if (this.modelSelector) {
             this.modelSelector.value = value;
         }
     }
 
     setLiverySelection(value) {
         if (this.liverySelector) {
             this.liverySelector.value = value;
         }
     }
 
     populateSelectors() {
         Object.entries(modelFiles).forEach(([folder]) => {
             const option = document.createElement('option');
             option.value = folder;
             option.textContent = folder;
             this.modelSelector.appendChild(option);
         });
 
         cubemaps.forEach((folder) => {
             const option = document.createElement('option');
             option.value = folder;
@@ -300,87 +322,481 @@ export class UIController {
                 this.materialManager.applyBodyColours();
             });
         });
 
         this.layerMaterialSelectors.forEach((selector, index) => {
             selector.addEventListener('change', (event) => {
                 const value = event.target.value;
                 this.state.bodyMaterials[index] = value;
                 if (index === 3) {
                     setCookie('rimMaterial', value);
                 } else {
                     setCookie(`materialPreset_baseLivery${index + 1}`, value);
                 }
                 this.materialManager.applyBodyColours();
             });
         });
 
         this.multiFileUpload.addEventListener('change', (event) => this.handleFileUpload(event));
 
         // Add post-processing toggle listener
         if (this.postProcessingToggle) {
             this.postProcessingToggle.addEventListener('change', (event) => {
                 this.togglePostProcessing(event.target.checked);
             });
         }
+
+        this.registerEditorPanelEvents();
     }
 
     registerDragAndDrop() {
         const dropZone = document.getElementById('dropZone');
         window.addEventListener('dragover', (event) => event.preventDefault());
         window.addEventListener('drop', (event) => event.preventDefault());
 
         dropZone.addEventListener('dragover', (event) => {
             event.preventDefault();
             dropZone.classList.add('dragging');
         });
 
         dropZone.addEventListener('dragleave', () => {
             dropZone.classList.remove('dragging');
         });
 
         dropZone.addEventListener('drop', (event) => {
             event.preventDefault();
             dropZone.classList.remove('dragging');
             if (event.dataTransfer && event.dataTransfer.files.length > 0) {
                 this.handleFileUpload({ target: { files: [...event.dataTransfer.files] } });
             }
         });
     }
 
+    registerEditorPanelEvents() {
+        if (this.editorPanelToggle && this.editorPanel) {
+            this.editorPanelToggle.addEventListener('click', () => {
+                const isOpen = !this.editorPanel.classList.contains('open');
+                this.setEditorPanelOpen(isOpen);
+            });
+        }
+
+        if (this.editorPanelClose && this.editorPanel) {
+            this.editorPanelClose.addEventListener('click', () => this.setEditorPanelOpen(false));
+        }
+
+        if (this.layerList) {
+            this.layerList.addEventListener('click', (event) => {
+                const item = event.target.closest('[data-layer-id]');
+                if (!item || !this.layerList.contains(item) || item.classList.contains('locked')) {
+                    return;
+                }
+                this.handleLayerSelection(item.dataset.layerId);
+            });
+        }
+
+        if (this.createLayerButton) {
+            this.createLayerButton.addEventListener('click', () => {
+                const snapshot = this.state.captureEditorState();
+                const layerIndex = this.state.layers.length + 1;
+                const newLayer = this.state.insertLayer({
+                    name: `Layer ${layerIndex}`,
+                    type: 'paint',
+                    metadata: { items: [] }
+                });
+                if (newLayer) {
+                    if (this.liveryEditor) {
+                        this.liveryEditor.ensureLayerSurface(newLayer);
+                        this.liveryEditor.setActiveLayer(newLayer.id);
+                    }
+                    this.state.recordUndoState(snapshot);
+                    this.state.setActiveLayer(newLayer.id);
+                    this.renderLayerList();
+                }
+            });
+        }
+
+        if (this.mergeLayerButton) {
+            this.mergeLayerButton.addEventListener('click', () => this.mergeActiveLayerDown());
+        }
+
+        if (this.toolSelect) {
+            this.toolSelect.addEventListener('change', (event) => {
+                this.state.setActiveTool(event.target.value);
+                if (this.liveryEditor) {
+                    this.liveryEditor.setActiveTool(event.target.value);
+                }
+            });
+        }
+
+        if (this.brushSizeRange) {
+            this.brushSizeRange.addEventListener('input', (event) => {
+                this.updateBrushSetting('size', Number(event.target.value));
+            });
+        }
+
+        if (this.brushOpacityRange) {
+            this.brushOpacityRange.addEventListener('input', (event) => {
+                this.updateBrushSetting('opacity', Number(event.target.value));
+            });
+        }
+
+        if (this.brushHardnessRange) {
+            this.brushHardnessRange.addEventListener('input', (event) => {
+                this.updateBrushSetting('hardness', Number(event.target.value));
+            });
+        }
+
+        if (this.mirrorToggleInput) {
+            this.mirrorToggleInput.addEventListener('change', (event) => {
+                this.state.setSymmetrySettings({ enabled: event.target.checked });
+                if (this.liveryEditor) {
+                    this.liveryEditor.setMirrorSettings({ ...this.state.symmetrySettings });
+                }
+            });
+        }
+
+        if (this.mirrorAxisSelect) {
+            this.mirrorAxisSelect.addEventListener('change', (event) => {
+                this.state.setSymmetrySettings({ axis: event.target.value });
+                if (this.liveryEditor) {
+                    this.liveryEditor.setMirrorSettings({ ...this.state.symmetrySettings, axis: event.target.value });
+                }
+            });
+        }
+
+        if (this.mirrorModeSelect) {
+            this.mirrorModeSelect.addEventListener('change', (event) => {
+                this.state.setSymmetrySettings({ mode: event.target.value });
+                if (this.liveryEditor) {
+                    this.liveryEditor.setMirrorSettings({ ...this.state.symmetrySettings, mode: event.target.value });
+                }
+            });
+        }
+
+        if (this.uvBackgroundToggle) {
+            this.uvBackgroundToggle.addEventListener('change', (event) => {
+                if (this.liveryEditor) {
+                    this.liveryEditor.setTemplateVisibility(event.target.checked);
+                }
+            });
+        }
+
+        if (this.stickerUploadInput) {
+            this.stickerUploadInput.addEventListener('change', (event) => {
+                if (event.target.files?.length) {
+                    this.handleStickerUpload(event.target.files[0]);
+                }
+                event.target.value = '';
+            });
+        }
+
+        if (this.textEntryForm) {
+            this.textEntryForm.addEventListener('submit', (event) => {
+                event.preventDefault();
+                const textValue = (this.textEntryInput?.value || '').trim();
+                if (!textValue) {
+                    return;
+                }
+                const snapshot = this.state.captureEditorState();
+                const newLayer = this.state.insertLayer({
+                    name: textValue,
+                    type: 'text',
+                    metadata: { items: [] }
+                });
+                if (newLayer) {
+                    if (this.liveryEditor) {
+                        this.liveryEditor.setActiveLayer(newLayer.id);
+                        this.liveryEditor.addTextToLayer(newLayer.id, textValue);
+                    }
+                    this.state.setActiveLayer(newLayer.id);
+                    this.state.recordUndoState(snapshot);
+                    this.renderLayerList();
+                }
+                if (this.textEntryInput) {
+                    this.textEntryInput.value = '';
+                }
+            });
+        }
+
+        if (this.exportLiveryButton) {
+            this.exportLiveryButton.addEventListener('click', () => {
+                document.dispatchEvent(new CustomEvent('editor:exportLivery'));
+            });
+        }
+    }
+
+    setEditorPanelOpen(isOpen) {
+        if (!this.editorPanel) {
+            return;
+        }
+        this.editorPanel.classList.toggle('open', Boolean(isOpen));
+        this.editorPanel.setAttribute('aria-hidden', (!isOpen).toString());
+        if (this.editorPanelToggle) {
+            this.editorPanelToggle.setAttribute('aria-expanded', Boolean(isOpen).toString());
+        }
+    }
+
+    ensureBrushSettings() {
+        if (!this.state.brushSettings) {
+            this.state.brushSettings = {
+                size: this.brushSizeRange ? Number(this.brushSizeRange.value) : 50,
+                opacity: this.brushOpacityRange ? Number(this.brushOpacityRange.value) : 1,
+                hardness: this.brushHardnessRange ? Number(this.brushHardnessRange.value) : 0.8,
+                color: '#ffffff',
+            };
+        } else {
+            this.state.brushSettings = {
+                size: this.state.brushSettings.size ?? (this.brushSizeRange ? Number(this.brushSizeRange.value) : 50),
+                opacity: this.state.brushSettings.opacity ?? (this.brushOpacityRange ? Number(this.brushOpacityRange.value) : 1),
+                hardness: this.state.brushSettings.hardness ?? (this.brushHardnessRange ? Number(this.brushHardnessRange.value) : 0.8),
+                color: this.state.brushSettings.color || '#ffffff',
+            };
+        }
+
+        if (this.liveryEditor) {
+            Object.entries(this.state.brushSettings).forEach(([key, value]) => {
+                this.liveryEditor.updateBrushSetting(key, value);
+            });
+        }
+    }
+
+    syncEditorPanelControls() {
+        if (this.toolSelect) {
+            if (this.state.activeTool) {
+                this.toolSelect.value = this.state.activeTool;
+            } else {
+                this.state.setActiveTool(this.toolSelect.value);
+            }
+            if (this.liveryEditor) {
+                this.liveryEditor.setActiveTool(this.state.activeTool || this.toolSelect.value);
+            }
+        }
+
+        const symmetry = this.state.symmetrySettings || {};
+        if (this.mirrorToggleInput) {
+            this.mirrorToggleInput.checked = Boolean(symmetry.enabled);
+        }
+        if (this.mirrorAxisSelect && symmetry.axis) {
+            this.mirrorAxisSelect.value = symmetry.axis;
+        }
+        if (this.mirrorModeSelect && symmetry.mode) {
+            this.mirrorModeSelect.value = symmetry.mode;
+        }
+        if (this.liveryEditor) {
+            this.liveryEditor.setMirrorSettings(symmetry);
+        }
+
+        if (this.state.brushSettings) {
+            if (this.brushSizeRange && typeof this.state.brushSettings.size === 'number') {
+                this.brushSizeRange.value = String(this.state.brushSettings.size);
+            }
+            if (this.brushOpacityRange && typeof this.state.brushSettings.opacity === 'number') {
+                this.brushOpacityRange.value = String(this.state.brushSettings.opacity);
+            }
+            if (this.brushHardnessRange && typeof this.state.brushSettings.hardness === 'number') {
+                this.brushHardnessRange.value = String(this.state.brushSettings.hardness);
+            }
+        }
+
+        if (this.uvBackgroundToggle && this.liveryEditor) {
+            this.uvBackgroundToggle.checked = this.liveryEditor.isTemplateVisible();
+        }
+    }
+
+    renderLayerList() {
+        if (!this.layerList) {
+            return;
+        }
+
+        this.layerList.innerHTML = '';
+        const layers = Array.isArray(this.state.layers) ? [...this.state.layers] : [];
+        if (!layers.length) {
+            const emptyItem = document.createElement('li');
+            emptyItem.className = 'layer-item layer-item-empty';
+            emptyItem.textContent = 'No layers yet';
+            this.layerList.appendChild(emptyItem);
+            return;
+        }
+
+        const orderedLayers = layers.slice().reverse();
+        orderedLayers.forEach((layer) => {
+            const listItem = document.createElement('li');
+            listItem.className = 'layer-item';
+            listItem.dataset.layerId = layer.id;
+
+            const isBaseLayer = Boolean(
+                this.state.baseLayers && (
+                    this.state.baseLayers.decals === layer.id ||
+                    this.state.baseLayers.sponsors === layer.id
+                )
+            );
+            const isLocked = isBaseLayer || layer.locked;
+            if (isLocked) {
+                listItem.classList.add('locked');
+            }
+            if (this.state.activeLayerId === layer.id) {
+                listItem.classList.add('active');
+            }
+
+            const nameSpan = document.createElement('span');
+            nameSpan.textContent = layer.name || layer.id;
+            listItem.appendChild(nameSpan);
+
+            const meta = document.createElement('span');
+            meta.className = 'layer-meta';
+            if (layer.type) {
+                const typeSpan = document.createElement('span');
+                typeSpan.className = 'layer-type';
+                typeSpan.textContent = layer.type;
+                meta.appendChild(typeSpan);
+            }
+            if (isLocked) {
+                const lockSpan = document.createElement('span');
+                lockSpan.className = 'layer-item-lock';
+                lockSpan.setAttribute('aria-label', 'Locked layer');
+                lockSpan.textContent = '🔒';
+                meta.appendChild(lockSpan);
+            }
+            if (meta.childNodes.length) {
+                listItem.appendChild(meta);
+            }
+
+            this.layerList.appendChild(listItem);
+        });
+    }
+
+    handleLayerSelection(layerId) {
+        if (!layerId) {
+            return;
+        }
+        this.state.setActiveLayer(layerId);
+        if (this.liveryEditor) {
+            this.liveryEditor.setActiveLayer(layerId);
+        }
+        this.renderLayerList();
+    }
+
+    mergeActiveLayerDown() {
+        const activeLayerId = this.state.activeLayerId;
+        if (!activeLayerId) {
+            console.warn('No active layer selected to merge.');
+            return;
+        }
+
+        const layers = Array.isArray(this.state.layers) ? this.state.layers : [];
+        const activeIndex = layers.findIndex((layer) => layer.id === activeLayerId);
+        if (activeIndex <= 0) {
+            console.warn('No available layer below to merge with.');
+            return;
+        }
+
+        const targetLayer = layers[activeIndex - 1];
+        const snapshot = this.state.captureEditorState();
+        const merged = this.state.mergeLayers(targetLayer.id, activeLayerId, () => {
+            if (this.liveryEditor) {
+                this.liveryEditor.mergeLayers(targetLayer.id, activeLayerId);
+            }
+        });
+        if (merged) {
+            this.state.recordUndoState(snapshot);
+            this.state.setActiveLayer(targetLayer.id);
+            if (this.liveryEditor) {
+                this.liveryEditor.setActiveLayer(targetLayer.id);
+            }
+            this.renderLayerList();
+        }
+    }
+
+    updateBrushSetting(key, value) {
+        if (!this.state.brushSettings) {
+            this.state.brushSettings = {};
+        }
+        this.state.brushSettings = {
+            ...this.state.brushSettings,
+            [key]: value,
+        };
+        if (this.liveryEditor) {
+            this.liveryEditor.updateBrushSetting(key, value);
+        }
+    }
+
     handleFileUpload(event) {
         const files = Array.from(event.target.files);
         files.forEach((file) => this.processFile(file));
         setTimeout(async () => {
             try {
                 await this.materialManager.mergeAndSetDecals(this.state.currentLivery);
             } catch (error) {
                 console.error('Failed to merge decals after upload', error);
             }
         }, 100);
     }
 
+    handleStickerUpload(file) {
+        if (!file || !this.liveryEditor) {
+            return;
+        }
+
+        const reader = new FileReader();
+        reader.onload = async (event) => {
+            const dataUrl = event.target?.result;
+            if (typeof dataUrl !== 'string') {
+                return;
+            }
+
+            const snapshot = this.state.captureEditorState();
+            let targetLayerId = this.state.activeLayerId;
+
+            if (!targetLayerId) {
+                const newLayer = this.state.insertLayer({
+                    name: file.name.replace(/\.[^/.]+$/, '') || `Sticker ${this.state.layers.length + 1}`,
+                    type: 'sticker',
+                    metadata: { items: [] }
+                });
+                if (newLayer) {
+                    targetLayerId = newLayer.id;
+                    this.state.setActiveLayer(targetLayerId);
+                    this.renderLayerList();
+                }
+            }
+
+            if (!targetLayerId) {
+                return;
+            }
+
+            const sticker = await this.liveryEditor.addStickerToLayer(targetLayerId, dataUrl, { name: file.name });
+            if (!sticker) {
+                return;
+            }
+            this.liveryEditor.setActiveLayer(targetLayerId);
+            this.state.setActiveLayer(targetLayerId);
+            this.state.recordUndoState(snapshot);
+            this.renderLayerList();
+        };
+        reader.readAsDataURL(file);
+    }
+
     processFile(file) {
         const reader = new FileReader();
         reader.onload = (event) => {
             if (isImageFile(event.target.result)) {
                 this.handleImageFile(file, event.target.result);
             } else {
                 this.handleJsonFile(file, event.target.result);
             }
         };
         reader.readAsDataURL(file);
     }
 
     handleImageFile(file, dataUrl) {
         const img = new Image();
         img.src = dataUrl;
         img.onload = () => {
             if (this.fileActions[file.name]) {
                 this.fileActions[file.name](file);
             }
         };
     }
 
     handleJsonFile(file, dataUrl) {
         const base64Data = dataUrl.split(',')[1];
         const content = JSON.parse(atob(base64Data));
diff --git a/style.css b/style.css
index 4b8065f86bb0c125303e825987f51d496738de1d..4d562d09af1b62adc4ebfaeb085a2fe085df19c0 100644
--- a/style.css
+++ b/style.css
@@ -1,53 +1,259 @@
 body {
     margin: 0;
     height: 100vh;
 }
 
-canvas {
-    border: 1px solid black;
-    margin-bottom: 10px;
+.app-shell {
+    position: relative;
+    min-height: 100vh;
+}
+
+.app-main {
+    padding-right: 1rem;
+}
+
+.workspace {
+    position: relative;
+    margin: 1rem;
+    border-radius: 0.5rem;
+    background: #ffffff;
+    box-shadow: 0 0 20px rgba(0, 0, 0, 0.08);
+    min-height: 420px;
+    border: 2px dashed transparent;
+    padding: 1rem;
+}
+
+.workspace-split {
+    display: flex;
+    flex-wrap: wrap;
+    gap: 1rem;
+    height: 100%;
+}
+
+.viewer-pane,
+.canvas-pane {
+    position: relative;
+    flex: 1 1 420px;
+    min-height: 420px;
+}
+
+.viewer-pane {
+    display: flex;
+    border-radius: 0.5rem;
+    background: #111;
+    overflow: hidden;
+}
+
+.canvas-pane {
+    display: flex;
+    flex-direction: column;
+    border-radius: 0.5rem;
+    background: #101215;
+    box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.06);
+    padding: 0.75rem;
+}
+
+#dropZone.dragging {
+    border: 2px dashed #0d6efd;
+    background-color: rgba(13, 110, 253, 0.1);
+}
+
+#modelContainer {
+    position: relative;
+    height: 100%;
+    flex: 1 1 auto;
+}
+
+#hiddenCanvas {
+    flex: 1 1 auto;
+    width: 100%;
+    height: auto;
+    max-width: 100%;
+    border-radius: 0.5rem;
+    border: 1px solid rgba(255, 255, 255, 0.08);
+    background-color: #1d1f24;
+    box-shadow: 0 12px 24px rgba(0, 0, 0, 0.18);
 }
 
 #overlay {
     position: absolute;
     top: 50;
     left: 0;
     padding: 10px;
     background-color: rgba(0, 0, 0, 0.7);
     color: white;
     font-family: Arial, sans-serif;
     font-size: 14px;
     z-index: 100;
 }
 #overlay p {
     margin: 5px 0;
 }
 
 /* Additional compact styling for Bootstrap elements */
 .card {
     margin-bottom: 0.5rem;
 }
 
 .card-header {
     padding: 0.25rem 0.25rem !important;
     font-size: 0.875rem;
 }
 
 .card-body {
     padding: 0.25rem;
 }
 
 .form-label {
     margin-bottom: 0.25rem;
     font-size: 0.875rem;
 }
 
 .btn {
     padding: 0.25rem 0.5rem;
     font-size: 0.875rem;
 }
 
 color-picker {
     margin-bottom: 0.5rem;
     vertical-align: middle;
 }
+
+.editor-panel-toggle {
+    position: fixed;
+    top: 1rem;
+    right: 1rem;
+    z-index: 1100;
+}
+
+.editor-panel {
+    position: fixed;
+    top: 0;
+    right: 0;
+    height: 100vh;
+    width: 320px;
+    max-width: 90vw;
+    background: #ffffff;
+    box-shadow: -4px 0 24px rgba(0, 0, 0, 0.15);
+    transform: translateX(100%);
+    transition: transform 0.3s ease-in-out;
+    z-index: 1090;
+    display: flex;
+    flex-direction: column;
+}
+
+.editor-panel.open {
+    transform: translateX(0);
+}
+
+.editor-panel-content {
+    padding: 1rem;
+    overflow-y: auto;
+    flex: 1 1 auto;
+}
+
+.editor-panel-title {
+    font-size: 1.25rem;
+    margin-bottom: 1rem;
+}
+
+.editor-panel-close {
+    align-self: flex-end;
+    background: none;
+    border: none;
+    font-size: 1.5rem;
+    line-height: 1;
+    padding: 0;
+    margin-bottom: 0.5rem;
+}
+
+.editor-section {
+    margin-bottom: 1.5rem;
+}
+
+.editor-section-title {
+    font-size: 1rem;
+    margin-bottom: 0.5rem;
+}
+
+.editor-section-note {
+    font-size: 0.75rem;
+    color: #6c757d;
+    margin-bottom: 0.5rem;
+}
+
+.layer-list {
+    list-style: none;
+    padding: 0;
+    margin: 0 0 0.75rem 0;
+}
+
+.layer-item {
+    display: flex;
+    align-items: center;
+    justify-content: space-between;
+    padding: 0.4rem 0.6rem;
+    border-radius: 0.35rem;
+    background: #f8f9fa;
+    border: 1px solid transparent;
+    cursor: pointer;
+    font-size: 0.85rem;
+}
+
+.layer-item + .layer-item {
+    margin-top: 0.35rem;
+}
+
+.layer-item.active {
+    border-color: #0d6efd;
+    background: rgba(13, 110, 253, 0.1);
+}
+
+.layer-item.locked {
+    opacity: 0.6;
+    cursor: not-allowed;
+}
+
+.layer-item-lock {
+    margin-left: 0.35rem;
+    font-size: 0.85rem;
+}
+
+.layer-item-empty {
+    justify-content: center;
+    color: #6c757d;
+    cursor: default;
+}
+
+.layer-meta {
+    display: flex;
+    align-items: center;
+    gap: 0.25rem;
+    font-size: 0.7rem;
+    text-transform: uppercase;
+    color: #6c757d;
+}
+
+.layer-type {
+    letter-spacing: 0.05em;
+}
+
+.layer-actions {
+    display: flex;
+    gap: 0.5rem;
+}
+
+.brush-settings label,
+.brush-settings input {
+    display: block;
+}
+
+.brush-settings input {
+    width: 100%;
+    margin-bottom: 0.5rem;
+}
+
+.text-entry-form {
+    display: flex;
+    flex-direction: column;
+}
